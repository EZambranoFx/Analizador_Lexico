Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    ARROW
    BREAK
    CASE
    CATCH
    COMMENT
    CONST
    CONSTRUCT
    CONTINUE
    DEFAULT
    DO
    DOLLAR
    ELSEIF
    ERROR
    EXTENDS
    FINALLY
    FOR
    FOREACH
    IDENTICAL
    IMPLEMENTS
    NEW
    NEWLINE
    NOT_IDENTICAL
    PRIVATE
    PROTECTED
    PUBLIC
    RETURN
    SET
    STATIC
    SWITCH
    THROW
    TRY
    VAR
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> print_statement
Rule 5     statement -> input_statement
Rule 6     statement -> expression_statement
Rule 7     statement -> assignment_statement
Rule 8     statement -> condition_statement
Rule 9     statement -> data_structure_statement
Rule 10    statement -> function_statement
Rule 11    statement -> class_statement
Rule 12    print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI
Rule 13    input_statement -> IDENTIFIER LPAREN RPAREN SEMI
Rule 14    argument_list -> expression
Rule 15    argument_list -> argument_list COMMA expression
Rule 16    expression_statement -> expression SEMI
Rule 17    assignment_statement -> VARIABLE EQ expression SEMI
Rule 18    condition_statement -> IF LPAREN condition RPAREN statement
Rule 19    condition_statement -> IF LPAREN condition RPAREN statement ELSE statement
Rule 20    data_structure_statement -> array_statement
Rule 21    data_structure_statement -> class_statement
Rule 22    array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
Rule 23    class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE
Rule 24    class_body -> class_body_element
Rule 25    class_body -> class_body class_body_element
Rule 26    class_body_element -> assignment_statement
Rule 27    class_body_element -> function_statement
Rule 28    function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
Rule 29    parameter_list -> VARIABLE
Rule 30    parameter_list -> parameter_list COMMA VARIABLE
Rule 31    parameter_list -> empty
Rule 32    condition -> expression comparison_operator expression
Rule 33    condition -> condition logical_operator condition
Rule 34    comparison_operator -> EQ
Rule 35    comparison_operator -> NE
Rule 36    comparison_operator -> LT
Rule 37    comparison_operator -> LE
Rule 38    comparison_operator -> GT
Rule 39    comparison_operator -> GE
Rule 40    logical_operator -> AND
Rule 41    logical_operator -> OR
Rule 42    logical_operator -> NOT
Rule 43    expression -> term
Rule 44    expression -> expression PLUS term
Rule 45    expression -> expression MINUS term
Rule 46    expression -> expression TIMES term
Rule 47    expression -> expression DIVIDE term
Rule 48    expression -> expression MOD term
Rule 49    expression -> expression EXP term
Rule 50    term -> INTEGER
Rule 51    term -> FLOAT
Rule 52    term -> STRING
Rule 53    term -> VARIABLE
Rule 54    term -> LPAREN expression RPAREN
Rule 55    empty -> <empty>

Terminals, with rules where they appear

AND                  : 40
ARRAY                : 
ARROW                : 
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 23
COMMA                : 15 30
COMMENT              : 
CONST                : 
CONSTRUCT            : 
CONTINUE             : 
DEFAULT              : 
DIVIDE               : 47
DO                   : 
DOLLAR               : 
ELSE                 : 19
ELSEIF               : 
EQ                   : 17 22 34
ERROR                : 
EXP                  : 49
EXTENDS              : 
FINALLY              : 
FLOAT                : 51
FOR                  : 
FOREACH              : 
FUNCTION             : 28
GE                   : 39
GT                   : 38
IDENTICAL            : 
IDENTIFIER           : 12 13 23 28
IF                   : 18 19
IMPLEMENTS           : 
INTEGER              : 50
LBRACE               : 23 28
LBRACKET             : 22
LE                   : 37
LPAREN               : 12 13 18 19 28 54
LT                   : 36
MINUS                : 45
MOD                  : 48
NE                   : 35
NEW                  : 
NEWLINE              : 
NOT                  : 42
NOT_IDENTICAL        : 
OR                   : 41
PLUS                 : 44
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
RBRACE               : 23 28
RBRACKET             : 22
RETURN               : 
RPAREN               : 12 13 18 19 28 54
SEMI                 : 12 13 16 17 22
SET                  : 
STATIC               : 
STRING               : 52
SWITCH               : 
THROW                : 
TIMES                : 46
TRY                  : 
VAR                  : 
VARIABLE             : 17 22 29 30 53
WHILE                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 12 15 22
array_statement      : 20
assignment_statement : 7 26
class_body           : 23 25
class_body_element   : 24 25
class_statement      : 11 21
comparison_operator  : 32
condition            : 18 19 33 33
condition_statement  : 8
data_structure_statement : 9
empty                : 31
expression           : 14 15 16 17 32 32 44 45 46 47 48 49 54
expression_statement : 6
function_statement   : 10 27
input_statement      : 5
logical_operator     : 33
parameter_list       : 28 30
print_statement      : 4
program              : 0
statement            : 2 3 18 19 19
statement_list       : 1 3 28
term                 : 43 44 45 46 47 48 49

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (13) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (16) expression_statement -> . expression SEMI
    (17) assignment_statement -> . VARIABLE EQ expression SEMI
    (18) condition_statement -> . IF LPAREN condition RPAREN statement
    (19) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (20) data_structure_statement -> . array_statement
    (21) data_structure_statement -> . class_statement
    (28) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (23) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (22) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 12
    VARIABLE        shift and go to state 15
    IF              shift and go to state 16
    FUNCTION        shift and go to state 18
    CLASS           shift and go to state 19
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    LPAREN          shift and go to state 13

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    expression                     shift and go to state 14
    array_statement                shift and go to state 17
    term                           shift and go to state 20

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (13) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (16) expression_statement -> . expression SEMI
    (17) assignment_statement -> . VARIABLE EQ expression SEMI
    (18) condition_statement -> . IF LPAREN condition RPAREN statement
    (19) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (20) data_structure_statement -> . array_statement
    (21) data_structure_statement -> . class_statement
    (28) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (23) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (22) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    $end            reduce using rule 1 (program -> statement_list .)
    IDENTIFIER      shift and go to state 12
    VARIABLE        shift and go to state 15
    IF              shift and go to state 16
    FUNCTION        shift and go to state 18
    CLASS           shift and go to state 19
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    LPAREN          shift and go to state 13

    statement                      shift and go to state 24
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    expression                     shift and go to state 14
    array_statement                shift and go to state 17
    term                           shift and go to state 20

state 3

    (2) statement_list -> statement .

    IDENTIFIER      reduce using rule 2 (statement_list -> statement .)
    VARIABLE        reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    FUNCTION        reduce using rule 2 (statement_list -> statement .)
    CLASS           reduce using rule 2 (statement_list -> statement .)
    INTEGER         reduce using rule 2 (statement_list -> statement .)
    FLOAT           reduce using rule 2 (statement_list -> statement .)
    STRING          reduce using rule 2 (statement_list -> statement .)
    LPAREN          reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> print_statement .

    IDENTIFIER      reduce using rule 4 (statement -> print_statement .)
    VARIABLE        reduce using rule 4 (statement -> print_statement .)
    IF              reduce using rule 4 (statement -> print_statement .)
    FUNCTION        reduce using rule 4 (statement -> print_statement .)
    CLASS           reduce using rule 4 (statement -> print_statement .)
    INTEGER         reduce using rule 4 (statement -> print_statement .)
    FLOAT           reduce using rule 4 (statement -> print_statement .)
    STRING          reduce using rule 4 (statement -> print_statement .)
    LPAREN          reduce using rule 4 (statement -> print_statement .)
    $end            reduce using rule 4 (statement -> print_statement .)
    ELSE            reduce using rule 4 (statement -> print_statement .)
    RBRACE          reduce using rule 4 (statement -> print_statement .)


state 5

    (5) statement -> input_statement .

    IDENTIFIER      reduce using rule 5 (statement -> input_statement .)
    VARIABLE        reduce using rule 5 (statement -> input_statement .)
    IF              reduce using rule 5 (statement -> input_statement .)
    FUNCTION        reduce using rule 5 (statement -> input_statement .)
    CLASS           reduce using rule 5 (statement -> input_statement .)
    INTEGER         reduce using rule 5 (statement -> input_statement .)
    FLOAT           reduce using rule 5 (statement -> input_statement .)
    STRING          reduce using rule 5 (statement -> input_statement .)
    LPAREN          reduce using rule 5 (statement -> input_statement .)
    $end            reduce using rule 5 (statement -> input_statement .)
    ELSE            reduce using rule 5 (statement -> input_statement .)
    RBRACE          reduce using rule 5 (statement -> input_statement .)


state 6

    (6) statement -> expression_statement .

    IDENTIFIER      reduce using rule 6 (statement -> expression_statement .)
    VARIABLE        reduce using rule 6 (statement -> expression_statement .)
    IF              reduce using rule 6 (statement -> expression_statement .)
    FUNCTION        reduce using rule 6 (statement -> expression_statement .)
    CLASS           reduce using rule 6 (statement -> expression_statement .)
    INTEGER         reduce using rule 6 (statement -> expression_statement .)
    FLOAT           reduce using rule 6 (statement -> expression_statement .)
    STRING          reduce using rule 6 (statement -> expression_statement .)
    LPAREN          reduce using rule 6 (statement -> expression_statement .)
    $end            reduce using rule 6 (statement -> expression_statement .)
    ELSE            reduce using rule 6 (statement -> expression_statement .)
    RBRACE          reduce using rule 6 (statement -> expression_statement .)


state 7

    (7) statement -> assignment_statement .

    IDENTIFIER      reduce using rule 7 (statement -> assignment_statement .)
    VARIABLE        reduce using rule 7 (statement -> assignment_statement .)
    IF              reduce using rule 7 (statement -> assignment_statement .)
    FUNCTION        reduce using rule 7 (statement -> assignment_statement .)
    CLASS           reduce using rule 7 (statement -> assignment_statement .)
    INTEGER         reduce using rule 7 (statement -> assignment_statement .)
    FLOAT           reduce using rule 7 (statement -> assignment_statement .)
    STRING          reduce using rule 7 (statement -> assignment_statement .)
    LPAREN          reduce using rule 7 (statement -> assignment_statement .)
    $end            reduce using rule 7 (statement -> assignment_statement .)
    ELSE            reduce using rule 7 (statement -> assignment_statement .)
    RBRACE          reduce using rule 7 (statement -> assignment_statement .)


state 8

    (8) statement -> condition_statement .

    IDENTIFIER      reduce using rule 8 (statement -> condition_statement .)
    VARIABLE        reduce using rule 8 (statement -> condition_statement .)
    IF              reduce using rule 8 (statement -> condition_statement .)
    FUNCTION        reduce using rule 8 (statement -> condition_statement .)
    CLASS           reduce using rule 8 (statement -> condition_statement .)
    INTEGER         reduce using rule 8 (statement -> condition_statement .)
    FLOAT           reduce using rule 8 (statement -> condition_statement .)
    STRING          reduce using rule 8 (statement -> condition_statement .)
    LPAREN          reduce using rule 8 (statement -> condition_statement .)
    $end            reduce using rule 8 (statement -> condition_statement .)
    ELSE            reduce using rule 8 (statement -> condition_statement .)
    RBRACE          reduce using rule 8 (statement -> condition_statement .)


state 9

    (9) statement -> data_structure_statement .

    IDENTIFIER      reduce using rule 9 (statement -> data_structure_statement .)
    VARIABLE        reduce using rule 9 (statement -> data_structure_statement .)
    IF              reduce using rule 9 (statement -> data_structure_statement .)
    FUNCTION        reduce using rule 9 (statement -> data_structure_statement .)
    CLASS           reduce using rule 9 (statement -> data_structure_statement .)
    INTEGER         reduce using rule 9 (statement -> data_structure_statement .)
    FLOAT           reduce using rule 9 (statement -> data_structure_statement .)
    STRING          reduce using rule 9 (statement -> data_structure_statement .)
    LPAREN          reduce using rule 9 (statement -> data_structure_statement .)
    $end            reduce using rule 9 (statement -> data_structure_statement .)
    ELSE            reduce using rule 9 (statement -> data_structure_statement .)
    RBRACE          reduce using rule 9 (statement -> data_structure_statement .)


state 10

    (10) statement -> function_statement .

    IDENTIFIER      reduce using rule 10 (statement -> function_statement .)
    VARIABLE        reduce using rule 10 (statement -> function_statement .)
    IF              reduce using rule 10 (statement -> function_statement .)
    FUNCTION        reduce using rule 10 (statement -> function_statement .)
    CLASS           reduce using rule 10 (statement -> function_statement .)
    INTEGER         reduce using rule 10 (statement -> function_statement .)
    FLOAT           reduce using rule 10 (statement -> function_statement .)
    STRING          reduce using rule 10 (statement -> function_statement .)
    LPAREN          reduce using rule 10 (statement -> function_statement .)
    $end            reduce using rule 10 (statement -> function_statement .)
    ELSE            reduce using rule 10 (statement -> function_statement .)
    RBRACE          reduce using rule 10 (statement -> function_statement .)


state 11

    (11) statement -> class_statement .
    (21) data_structure_statement -> class_statement .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for IF resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for CLASS resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for INTEGER resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for STRING resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 11 (statement -> class_statement .)
    IDENTIFIER      reduce using rule 11 (statement -> class_statement .)
    VARIABLE        reduce using rule 11 (statement -> class_statement .)
    IF              reduce using rule 11 (statement -> class_statement .)
    FUNCTION        reduce using rule 11 (statement -> class_statement .)
    CLASS           reduce using rule 11 (statement -> class_statement .)
    INTEGER         reduce using rule 11 (statement -> class_statement .)
    FLOAT           reduce using rule 11 (statement -> class_statement .)
    STRING          reduce using rule 11 (statement -> class_statement .)
    LPAREN          reduce using rule 11 (statement -> class_statement .)
    $end            reduce using rule 11 (statement -> class_statement .)
    ELSE            reduce using rule 11 (statement -> class_statement .)
    RBRACE          reduce using rule 11 (statement -> class_statement .)

  ! IDENTIFIER      [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! VARIABLE        [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! IF              [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! FUNCTION        [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! CLASS           [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! INTEGER         [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! FLOAT           [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! STRING          [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! LPAREN          [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! $end            [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! ELSE            [ reduce using rule 21 (data_structure_statement -> class_statement .) ]
  ! RBRACE          [ reduce using rule 21 (data_structure_statement -> class_statement .) ]


state 12

    (12) print_statement -> IDENTIFIER . LPAREN argument_list RPAREN SEMI
    (13) input_statement -> IDENTIFIER . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 25


state 13

    (54) term -> LPAREN . expression RPAREN
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    expression                     shift and go to state 26
    term                           shift and go to state 20

state 14

    (16) expression_statement -> expression . SEMI
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (46) expression -> expression . TIMES term
    (47) expression -> expression . DIVIDE term
    (48) expression -> expression . MOD term
    (49) expression -> expression . EXP term

    SEMI            shift and go to state 28
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    MOD             shift and go to state 33
    EXP             shift and go to state 34


state 15

    (17) assignment_statement -> VARIABLE . EQ expression SEMI
    (22) array_statement -> VARIABLE . EQ LBRACKET argument_list RBRACKET SEMI
    (53) term -> VARIABLE .

    EQ              shift and go to state 35
    SEMI            reduce using rule 53 (term -> VARIABLE .)
    PLUS            reduce using rule 53 (term -> VARIABLE .)
    MINUS           reduce using rule 53 (term -> VARIABLE .)
    TIMES           reduce using rule 53 (term -> VARIABLE .)
    DIVIDE          reduce using rule 53 (term -> VARIABLE .)
    MOD             reduce using rule 53 (term -> VARIABLE .)
    EXP             reduce using rule 53 (term -> VARIABLE .)


state 16

    (18) condition_statement -> IF . LPAREN condition RPAREN statement
    (19) condition_statement -> IF . LPAREN condition RPAREN statement ELSE statement

    LPAREN          shift and go to state 36


state 17

    (20) data_structure_statement -> array_statement .

    IDENTIFIER      reduce using rule 20 (data_structure_statement -> array_statement .)
    VARIABLE        reduce using rule 20 (data_structure_statement -> array_statement .)
    IF              reduce using rule 20 (data_structure_statement -> array_statement .)
    FUNCTION        reduce using rule 20 (data_structure_statement -> array_statement .)
    CLASS           reduce using rule 20 (data_structure_statement -> array_statement .)
    INTEGER         reduce using rule 20 (data_structure_statement -> array_statement .)
    FLOAT           reduce using rule 20 (data_structure_statement -> array_statement .)
    STRING          reduce using rule 20 (data_structure_statement -> array_statement .)
    LPAREN          reduce using rule 20 (data_structure_statement -> array_statement .)
    $end            reduce using rule 20 (data_structure_statement -> array_statement .)
    ELSE            reduce using rule 20 (data_structure_statement -> array_statement .)
    RBRACE          reduce using rule 20 (data_structure_statement -> array_statement .)


state 18

    (28) function_statement -> FUNCTION . IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    IDENTIFIER      shift and go to state 37


state 19

    (23) class_statement -> CLASS . IDENTIFIER LBRACE class_body RBRACE

    IDENTIFIER      shift and go to state 38


state 20

    (43) expression -> term .

    SEMI            reduce using rule 43 (expression -> term .)
    PLUS            reduce using rule 43 (expression -> term .)
    MINUS           reduce using rule 43 (expression -> term .)
    TIMES           reduce using rule 43 (expression -> term .)
    DIVIDE          reduce using rule 43 (expression -> term .)
    MOD             reduce using rule 43 (expression -> term .)
    EXP             reduce using rule 43 (expression -> term .)
    RPAREN          reduce using rule 43 (expression -> term .)
    COMMA           reduce using rule 43 (expression -> term .)
    EQ              reduce using rule 43 (expression -> term .)
    NE              reduce using rule 43 (expression -> term .)
    LT              reduce using rule 43 (expression -> term .)
    LE              reduce using rule 43 (expression -> term .)
    GT              reduce using rule 43 (expression -> term .)
    GE              reduce using rule 43 (expression -> term .)
    RBRACKET        reduce using rule 43 (expression -> term .)
    AND             reduce using rule 43 (expression -> term .)
    OR              reduce using rule 43 (expression -> term .)
    NOT             reduce using rule 43 (expression -> term .)


state 21

    (50) term -> INTEGER .

    SEMI            reduce using rule 50 (term -> INTEGER .)
    PLUS            reduce using rule 50 (term -> INTEGER .)
    MINUS           reduce using rule 50 (term -> INTEGER .)
    TIMES           reduce using rule 50 (term -> INTEGER .)
    DIVIDE          reduce using rule 50 (term -> INTEGER .)
    MOD             reduce using rule 50 (term -> INTEGER .)
    EXP             reduce using rule 50 (term -> INTEGER .)
    RPAREN          reduce using rule 50 (term -> INTEGER .)
    COMMA           reduce using rule 50 (term -> INTEGER .)
    EQ              reduce using rule 50 (term -> INTEGER .)
    NE              reduce using rule 50 (term -> INTEGER .)
    LT              reduce using rule 50 (term -> INTEGER .)
    LE              reduce using rule 50 (term -> INTEGER .)
    GT              reduce using rule 50 (term -> INTEGER .)
    GE              reduce using rule 50 (term -> INTEGER .)
    RBRACKET        reduce using rule 50 (term -> INTEGER .)
    AND             reduce using rule 50 (term -> INTEGER .)
    OR              reduce using rule 50 (term -> INTEGER .)
    NOT             reduce using rule 50 (term -> INTEGER .)


state 22

    (51) term -> FLOAT .

    SEMI            reduce using rule 51 (term -> FLOAT .)
    PLUS            reduce using rule 51 (term -> FLOAT .)
    MINUS           reduce using rule 51 (term -> FLOAT .)
    TIMES           reduce using rule 51 (term -> FLOAT .)
    DIVIDE          reduce using rule 51 (term -> FLOAT .)
    MOD             reduce using rule 51 (term -> FLOAT .)
    EXP             reduce using rule 51 (term -> FLOAT .)
    RPAREN          reduce using rule 51 (term -> FLOAT .)
    COMMA           reduce using rule 51 (term -> FLOAT .)
    EQ              reduce using rule 51 (term -> FLOAT .)
    NE              reduce using rule 51 (term -> FLOAT .)
    LT              reduce using rule 51 (term -> FLOAT .)
    LE              reduce using rule 51 (term -> FLOAT .)
    GT              reduce using rule 51 (term -> FLOAT .)
    GE              reduce using rule 51 (term -> FLOAT .)
    RBRACKET        reduce using rule 51 (term -> FLOAT .)
    AND             reduce using rule 51 (term -> FLOAT .)
    OR              reduce using rule 51 (term -> FLOAT .)
    NOT             reduce using rule 51 (term -> FLOAT .)


state 23

    (52) term -> STRING .

    SEMI            reduce using rule 52 (term -> STRING .)
    PLUS            reduce using rule 52 (term -> STRING .)
    MINUS           reduce using rule 52 (term -> STRING .)
    TIMES           reduce using rule 52 (term -> STRING .)
    DIVIDE          reduce using rule 52 (term -> STRING .)
    MOD             reduce using rule 52 (term -> STRING .)
    EXP             reduce using rule 52 (term -> STRING .)
    RPAREN          reduce using rule 52 (term -> STRING .)
    COMMA           reduce using rule 52 (term -> STRING .)
    EQ              reduce using rule 52 (term -> STRING .)
    NE              reduce using rule 52 (term -> STRING .)
    LT              reduce using rule 52 (term -> STRING .)
    LE              reduce using rule 52 (term -> STRING .)
    GT              reduce using rule 52 (term -> STRING .)
    GE              reduce using rule 52 (term -> STRING .)
    RBRACKET        reduce using rule 52 (term -> STRING .)
    AND             reduce using rule 52 (term -> STRING .)
    OR              reduce using rule 52 (term -> STRING .)
    NOT             reduce using rule 52 (term -> STRING .)


state 24

    (3) statement_list -> statement_list statement .

    IDENTIFIER      reduce using rule 3 (statement_list -> statement_list statement .)
    VARIABLE        reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    FUNCTION        reduce using rule 3 (statement_list -> statement_list statement .)
    CLASS           reduce using rule 3 (statement_list -> statement_list statement .)
    INTEGER         reduce using rule 3 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 3 (statement_list -> statement_list statement .)
    STRING          reduce using rule 3 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement_list statement .)


state 25

    (12) print_statement -> IDENTIFIER LPAREN . argument_list RPAREN SEMI
    (13) input_statement -> IDENTIFIER LPAREN . RPAREN SEMI
    (14) argument_list -> . expression
    (15) argument_list -> . argument_list COMMA expression
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    RPAREN          shift and go to state 40
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    argument_list                  shift and go to state 39
    expression                     shift and go to state 41
    term                           shift and go to state 20

state 26

    (54) term -> LPAREN expression . RPAREN
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (46) expression -> expression . TIMES term
    (47) expression -> expression . DIVIDE term
    (48) expression -> expression . MOD term
    (49) expression -> expression . EXP term

    RPAREN          shift and go to state 42
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    MOD             shift and go to state 33
    EXP             shift and go to state 34


state 27

    (53) term -> VARIABLE .

    RPAREN          reduce using rule 53 (term -> VARIABLE .)
    PLUS            reduce using rule 53 (term -> VARIABLE .)
    MINUS           reduce using rule 53 (term -> VARIABLE .)
    TIMES           reduce using rule 53 (term -> VARIABLE .)
    DIVIDE          reduce using rule 53 (term -> VARIABLE .)
    MOD             reduce using rule 53 (term -> VARIABLE .)
    EXP             reduce using rule 53 (term -> VARIABLE .)
    COMMA           reduce using rule 53 (term -> VARIABLE .)
    SEMI            reduce using rule 53 (term -> VARIABLE .)
    EQ              reduce using rule 53 (term -> VARIABLE .)
    NE              reduce using rule 53 (term -> VARIABLE .)
    LT              reduce using rule 53 (term -> VARIABLE .)
    LE              reduce using rule 53 (term -> VARIABLE .)
    GT              reduce using rule 53 (term -> VARIABLE .)
    GE              reduce using rule 53 (term -> VARIABLE .)
    RBRACKET        reduce using rule 53 (term -> VARIABLE .)
    AND             reduce using rule 53 (term -> VARIABLE .)
    OR              reduce using rule 53 (term -> VARIABLE .)
    NOT             reduce using rule 53 (term -> VARIABLE .)


state 28

    (16) expression_statement -> expression SEMI .

    IDENTIFIER      reduce using rule 16 (expression_statement -> expression SEMI .)
    VARIABLE        reduce using rule 16 (expression_statement -> expression SEMI .)
    IF              reduce using rule 16 (expression_statement -> expression SEMI .)
    FUNCTION        reduce using rule 16 (expression_statement -> expression SEMI .)
    CLASS           reduce using rule 16 (expression_statement -> expression SEMI .)
    INTEGER         reduce using rule 16 (expression_statement -> expression SEMI .)
    FLOAT           reduce using rule 16 (expression_statement -> expression SEMI .)
    STRING          reduce using rule 16 (expression_statement -> expression SEMI .)
    LPAREN          reduce using rule 16 (expression_statement -> expression SEMI .)
    $end            reduce using rule 16 (expression_statement -> expression SEMI .)
    ELSE            reduce using rule 16 (expression_statement -> expression SEMI .)
    RBRACE          reduce using rule 16 (expression_statement -> expression SEMI .)


state 29

    (44) expression -> expression PLUS . term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    term                           shift and go to state 43

state 30

    (45) expression -> expression MINUS . term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    term                           shift and go to state 44

state 31

    (46) expression -> expression TIMES . term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    term                           shift and go to state 45

state 32

    (47) expression -> expression DIVIDE . term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    term                           shift and go to state 46

state 33

    (48) expression -> expression MOD . term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    term                           shift and go to state 47

state 34

    (49) expression -> expression EXP . term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    term                           shift and go to state 48

state 35

    (17) assignment_statement -> VARIABLE EQ . expression SEMI
    (22) array_statement -> VARIABLE EQ . LBRACKET argument_list RBRACKET SEMI
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    LBRACKET        shift and go to state 50
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    expression                     shift and go to state 49
    term                           shift and go to state 20

state 36

    (18) condition_statement -> IF LPAREN . condition RPAREN statement
    (19) condition_statement -> IF LPAREN . condition RPAREN statement ELSE statement
    (32) condition -> . expression comparison_operator expression
    (33) condition -> . condition logical_operator condition
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    condition                      shift and go to state 51
    expression                     shift and go to state 52
    term                           shift and go to state 20

state 37

    (28) function_statement -> FUNCTION IDENTIFIER . LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 53


state 38

    (23) class_statement -> CLASS IDENTIFIER . LBRACE class_body RBRACE

    LBRACE          shift and go to state 54


state 39

    (12) print_statement -> IDENTIFIER LPAREN argument_list . RPAREN SEMI
    (15) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 55
    COMMA           shift and go to state 56


state 40

    (13) input_statement -> IDENTIFIER LPAREN RPAREN . SEMI

    SEMI            shift and go to state 57


state 41

    (14) argument_list -> expression .
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (46) expression -> expression . TIMES term
    (47) expression -> expression . DIVIDE term
    (48) expression -> expression . MOD term
    (49) expression -> expression . EXP term

    RPAREN          reduce using rule 14 (argument_list -> expression .)
    COMMA           reduce using rule 14 (argument_list -> expression .)
    RBRACKET        reduce using rule 14 (argument_list -> expression .)
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    MOD             shift and go to state 33
    EXP             shift and go to state 34


state 42

    (54) term -> LPAREN expression RPAREN .

    SEMI            reduce using rule 54 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 54 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 54 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 54 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 54 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 54 (term -> LPAREN expression RPAREN .)
    EXP             reduce using rule 54 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 54 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 54 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    NE              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    LE              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    GE              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 54 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 54 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    NOT             reduce using rule 54 (term -> LPAREN expression RPAREN .)


state 43

    (44) expression -> expression PLUS term .

    SEMI            reduce using rule 44 (expression -> expression PLUS term .)
    PLUS            reduce using rule 44 (expression -> expression PLUS term .)
    MINUS           reduce using rule 44 (expression -> expression PLUS term .)
    TIMES           reduce using rule 44 (expression -> expression PLUS term .)
    DIVIDE          reduce using rule 44 (expression -> expression PLUS term .)
    MOD             reduce using rule 44 (expression -> expression PLUS term .)
    EXP             reduce using rule 44 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 44 (expression -> expression PLUS term .)
    COMMA           reduce using rule 44 (expression -> expression PLUS term .)
    EQ              reduce using rule 44 (expression -> expression PLUS term .)
    NE              reduce using rule 44 (expression -> expression PLUS term .)
    LT              reduce using rule 44 (expression -> expression PLUS term .)
    LE              reduce using rule 44 (expression -> expression PLUS term .)
    GT              reduce using rule 44 (expression -> expression PLUS term .)
    GE              reduce using rule 44 (expression -> expression PLUS term .)
    RBRACKET        reduce using rule 44 (expression -> expression PLUS term .)
    AND             reduce using rule 44 (expression -> expression PLUS term .)
    OR              reduce using rule 44 (expression -> expression PLUS term .)
    NOT             reduce using rule 44 (expression -> expression PLUS term .)


state 44

    (45) expression -> expression MINUS term .

    SEMI            reduce using rule 45 (expression -> expression MINUS term .)
    PLUS            reduce using rule 45 (expression -> expression MINUS term .)
    MINUS           reduce using rule 45 (expression -> expression MINUS term .)
    TIMES           reduce using rule 45 (expression -> expression MINUS term .)
    DIVIDE          reduce using rule 45 (expression -> expression MINUS term .)
    MOD             reduce using rule 45 (expression -> expression MINUS term .)
    EXP             reduce using rule 45 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 45 (expression -> expression MINUS term .)
    COMMA           reduce using rule 45 (expression -> expression MINUS term .)
    EQ              reduce using rule 45 (expression -> expression MINUS term .)
    NE              reduce using rule 45 (expression -> expression MINUS term .)
    LT              reduce using rule 45 (expression -> expression MINUS term .)
    LE              reduce using rule 45 (expression -> expression MINUS term .)
    GT              reduce using rule 45 (expression -> expression MINUS term .)
    GE              reduce using rule 45 (expression -> expression MINUS term .)
    RBRACKET        reduce using rule 45 (expression -> expression MINUS term .)
    AND             reduce using rule 45 (expression -> expression MINUS term .)
    OR              reduce using rule 45 (expression -> expression MINUS term .)
    NOT             reduce using rule 45 (expression -> expression MINUS term .)


state 45

    (46) expression -> expression TIMES term .

    SEMI            reduce using rule 46 (expression -> expression TIMES term .)
    PLUS            reduce using rule 46 (expression -> expression TIMES term .)
    MINUS           reduce using rule 46 (expression -> expression TIMES term .)
    TIMES           reduce using rule 46 (expression -> expression TIMES term .)
    DIVIDE          reduce using rule 46 (expression -> expression TIMES term .)
    MOD             reduce using rule 46 (expression -> expression TIMES term .)
    EXP             reduce using rule 46 (expression -> expression TIMES term .)
    RPAREN          reduce using rule 46 (expression -> expression TIMES term .)
    COMMA           reduce using rule 46 (expression -> expression TIMES term .)
    EQ              reduce using rule 46 (expression -> expression TIMES term .)
    NE              reduce using rule 46 (expression -> expression TIMES term .)
    LT              reduce using rule 46 (expression -> expression TIMES term .)
    LE              reduce using rule 46 (expression -> expression TIMES term .)
    GT              reduce using rule 46 (expression -> expression TIMES term .)
    GE              reduce using rule 46 (expression -> expression TIMES term .)
    RBRACKET        reduce using rule 46 (expression -> expression TIMES term .)
    AND             reduce using rule 46 (expression -> expression TIMES term .)
    OR              reduce using rule 46 (expression -> expression TIMES term .)
    NOT             reduce using rule 46 (expression -> expression TIMES term .)


state 46

    (47) expression -> expression DIVIDE term .

    SEMI            reduce using rule 47 (expression -> expression DIVIDE term .)
    PLUS            reduce using rule 47 (expression -> expression DIVIDE term .)
    MINUS           reduce using rule 47 (expression -> expression DIVIDE term .)
    TIMES           reduce using rule 47 (expression -> expression DIVIDE term .)
    DIVIDE          reduce using rule 47 (expression -> expression DIVIDE term .)
    MOD             reduce using rule 47 (expression -> expression DIVIDE term .)
    EXP             reduce using rule 47 (expression -> expression DIVIDE term .)
    RPAREN          reduce using rule 47 (expression -> expression DIVIDE term .)
    COMMA           reduce using rule 47 (expression -> expression DIVIDE term .)
    EQ              reduce using rule 47 (expression -> expression DIVIDE term .)
    NE              reduce using rule 47 (expression -> expression DIVIDE term .)
    LT              reduce using rule 47 (expression -> expression DIVIDE term .)
    LE              reduce using rule 47 (expression -> expression DIVIDE term .)
    GT              reduce using rule 47 (expression -> expression DIVIDE term .)
    GE              reduce using rule 47 (expression -> expression DIVIDE term .)
    RBRACKET        reduce using rule 47 (expression -> expression DIVIDE term .)
    AND             reduce using rule 47 (expression -> expression DIVIDE term .)
    OR              reduce using rule 47 (expression -> expression DIVIDE term .)
    NOT             reduce using rule 47 (expression -> expression DIVIDE term .)


state 47

    (48) expression -> expression MOD term .

    SEMI            reduce using rule 48 (expression -> expression MOD term .)
    PLUS            reduce using rule 48 (expression -> expression MOD term .)
    MINUS           reduce using rule 48 (expression -> expression MOD term .)
    TIMES           reduce using rule 48 (expression -> expression MOD term .)
    DIVIDE          reduce using rule 48 (expression -> expression MOD term .)
    MOD             reduce using rule 48 (expression -> expression MOD term .)
    EXP             reduce using rule 48 (expression -> expression MOD term .)
    RPAREN          reduce using rule 48 (expression -> expression MOD term .)
    COMMA           reduce using rule 48 (expression -> expression MOD term .)
    EQ              reduce using rule 48 (expression -> expression MOD term .)
    NE              reduce using rule 48 (expression -> expression MOD term .)
    LT              reduce using rule 48 (expression -> expression MOD term .)
    LE              reduce using rule 48 (expression -> expression MOD term .)
    GT              reduce using rule 48 (expression -> expression MOD term .)
    GE              reduce using rule 48 (expression -> expression MOD term .)
    RBRACKET        reduce using rule 48 (expression -> expression MOD term .)
    AND             reduce using rule 48 (expression -> expression MOD term .)
    OR              reduce using rule 48 (expression -> expression MOD term .)
    NOT             reduce using rule 48 (expression -> expression MOD term .)


state 48

    (49) expression -> expression EXP term .

    SEMI            reduce using rule 49 (expression -> expression EXP term .)
    PLUS            reduce using rule 49 (expression -> expression EXP term .)
    MINUS           reduce using rule 49 (expression -> expression EXP term .)
    TIMES           reduce using rule 49 (expression -> expression EXP term .)
    DIVIDE          reduce using rule 49 (expression -> expression EXP term .)
    MOD             reduce using rule 49 (expression -> expression EXP term .)
    EXP             reduce using rule 49 (expression -> expression EXP term .)
    RPAREN          reduce using rule 49 (expression -> expression EXP term .)
    COMMA           reduce using rule 49 (expression -> expression EXP term .)
    EQ              reduce using rule 49 (expression -> expression EXP term .)
    NE              reduce using rule 49 (expression -> expression EXP term .)
    LT              reduce using rule 49 (expression -> expression EXP term .)
    LE              reduce using rule 49 (expression -> expression EXP term .)
    GT              reduce using rule 49 (expression -> expression EXP term .)
    GE              reduce using rule 49 (expression -> expression EXP term .)
    RBRACKET        reduce using rule 49 (expression -> expression EXP term .)
    AND             reduce using rule 49 (expression -> expression EXP term .)
    OR              reduce using rule 49 (expression -> expression EXP term .)
    NOT             reduce using rule 49 (expression -> expression EXP term .)


state 49

    (17) assignment_statement -> VARIABLE EQ expression . SEMI
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (46) expression -> expression . TIMES term
    (47) expression -> expression . DIVIDE term
    (48) expression -> expression . MOD term
    (49) expression -> expression . EXP term

    SEMI            shift and go to state 58
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    MOD             shift and go to state 33
    EXP             shift and go to state 34


state 50

    (22) array_statement -> VARIABLE EQ LBRACKET . argument_list RBRACKET SEMI
    (14) argument_list -> . expression
    (15) argument_list -> . argument_list COMMA expression
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    argument_list                  shift and go to state 59
    expression                     shift and go to state 41
    term                           shift and go to state 20

state 51

    (18) condition_statement -> IF LPAREN condition . RPAREN statement
    (19) condition_statement -> IF LPAREN condition . RPAREN statement ELSE statement
    (33) condition -> condition . logical_operator condition
    (40) logical_operator -> . AND
    (41) logical_operator -> . OR
    (42) logical_operator -> . NOT

    RPAREN          shift and go to state 60
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64

    logical_operator               shift and go to state 61

state 52

    (32) condition -> expression . comparison_operator expression
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (46) expression -> expression . TIMES term
    (47) expression -> expression . DIVIDE term
    (48) expression -> expression . MOD term
    (49) expression -> expression . EXP term
    (34) comparison_operator -> . EQ
    (35) comparison_operator -> . NE
    (36) comparison_operator -> . LT
    (37) comparison_operator -> . LE
    (38) comparison_operator -> . GT
    (39) comparison_operator -> . GE

    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    MOD             shift and go to state 33
    EXP             shift and go to state 34
    EQ              shift and go to state 66
    NE              shift and go to state 67
    LT              shift and go to state 68
    LE              shift and go to state 69
    GT              shift and go to state 70
    GE              shift and go to state 71

    comparison_operator            shift and go to state 65

state 53

    (28) function_statement -> FUNCTION IDENTIFIER LPAREN . parameter_list RPAREN LBRACE statement_list RBRACE
    (29) parameter_list -> . VARIABLE
    (30) parameter_list -> . parameter_list COMMA VARIABLE
    (31) parameter_list -> . empty
    (55) empty -> .

    VARIABLE        shift and go to state 73
    RPAREN          reduce using rule 55 (empty -> .)
    COMMA           reduce using rule 55 (empty -> .)

    parameter_list                 shift and go to state 72
    empty                          shift and go to state 74

state 54

    (23) class_statement -> CLASS IDENTIFIER LBRACE . class_body RBRACE
    (24) class_body -> . class_body_element
    (25) class_body -> . class_body class_body_element
    (26) class_body_element -> . assignment_statement
    (27) class_body_element -> . function_statement
    (17) assignment_statement -> . VARIABLE EQ expression SEMI
    (28) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    VARIABLE        shift and go to state 79
    FUNCTION        shift and go to state 18

    class_body                     shift and go to state 75
    class_body_element             shift and go to state 76
    assignment_statement           shift and go to state 77
    function_statement             shift and go to state 78

state 55

    (12) print_statement -> IDENTIFIER LPAREN argument_list RPAREN . SEMI

    SEMI            shift and go to state 80


state 56

    (15) argument_list -> argument_list COMMA . expression
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    expression                     shift and go to state 81
    term                           shift and go to state 20

state 57

    (13) input_statement -> IDENTIFIER LPAREN RPAREN SEMI .

    IDENTIFIER      reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    VARIABLE        reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    IF              reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    FUNCTION        reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    CLASS           reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    INTEGER         reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    FLOAT           reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    STRING          reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    LPAREN          reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    $end            reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    ELSE            reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    RBRACE          reduce using rule 13 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)


state 58

    (17) assignment_statement -> VARIABLE EQ expression SEMI .

    IDENTIFIER      reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    VARIABLE        reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    IF              reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    FUNCTION        reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    CLASS           reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    INTEGER         reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    FLOAT           reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    STRING          reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    LPAREN          reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    $end            reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    RBRACE          reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)
    ELSE            reduce using rule 17 (assignment_statement -> VARIABLE EQ expression SEMI .)


state 59

    (22) array_statement -> VARIABLE EQ LBRACKET argument_list . RBRACKET SEMI
    (15) argument_list -> argument_list . COMMA expression

    RBRACKET        shift and go to state 82
    COMMA           shift and go to state 56


state 60

    (18) condition_statement -> IF LPAREN condition RPAREN . statement
    (19) condition_statement -> IF LPAREN condition RPAREN . statement ELSE statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (13) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (16) expression_statement -> . expression SEMI
    (17) assignment_statement -> . VARIABLE EQ expression SEMI
    (18) condition_statement -> . IF LPAREN condition RPAREN statement
    (19) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (20) data_structure_statement -> . array_statement
    (21) data_structure_statement -> . class_statement
    (28) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (23) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (22) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 12
    VARIABLE        shift and go to state 15
    IF              shift and go to state 16
    FUNCTION        shift and go to state 18
    CLASS           shift and go to state 19
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    LPAREN          shift and go to state 13

    statement                      shift and go to state 83
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    expression                     shift and go to state 14
    array_statement                shift and go to state 17
    term                           shift and go to state 20

state 61

    (33) condition -> condition logical_operator . condition
    (32) condition -> . expression comparison_operator expression
    (33) condition -> . condition logical_operator condition
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    condition                      shift and go to state 84
    expression                     shift and go to state 52
    term                           shift and go to state 20

state 62

    (40) logical_operator -> AND .

    INTEGER         reduce using rule 40 (logical_operator -> AND .)
    FLOAT           reduce using rule 40 (logical_operator -> AND .)
    STRING          reduce using rule 40 (logical_operator -> AND .)
    VARIABLE        reduce using rule 40 (logical_operator -> AND .)
    LPAREN          reduce using rule 40 (logical_operator -> AND .)


state 63

    (41) logical_operator -> OR .

    INTEGER         reduce using rule 41 (logical_operator -> OR .)
    FLOAT           reduce using rule 41 (logical_operator -> OR .)
    STRING          reduce using rule 41 (logical_operator -> OR .)
    VARIABLE        reduce using rule 41 (logical_operator -> OR .)
    LPAREN          reduce using rule 41 (logical_operator -> OR .)


state 64

    (42) logical_operator -> NOT .

    INTEGER         reduce using rule 42 (logical_operator -> NOT .)
    FLOAT           reduce using rule 42 (logical_operator -> NOT .)
    STRING          reduce using rule 42 (logical_operator -> NOT .)
    VARIABLE        reduce using rule 42 (logical_operator -> NOT .)
    LPAREN          reduce using rule 42 (logical_operator -> NOT .)


state 65

    (32) condition -> expression comparison_operator . expression
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    expression                     shift and go to state 85
    term                           shift and go to state 20

state 66

    (34) comparison_operator -> EQ .

    INTEGER         reduce using rule 34 (comparison_operator -> EQ .)
    FLOAT           reduce using rule 34 (comparison_operator -> EQ .)
    STRING          reduce using rule 34 (comparison_operator -> EQ .)
    VARIABLE        reduce using rule 34 (comparison_operator -> EQ .)
    LPAREN          reduce using rule 34 (comparison_operator -> EQ .)


state 67

    (35) comparison_operator -> NE .

    INTEGER         reduce using rule 35 (comparison_operator -> NE .)
    FLOAT           reduce using rule 35 (comparison_operator -> NE .)
    STRING          reduce using rule 35 (comparison_operator -> NE .)
    VARIABLE        reduce using rule 35 (comparison_operator -> NE .)
    LPAREN          reduce using rule 35 (comparison_operator -> NE .)


state 68

    (36) comparison_operator -> LT .

    INTEGER         reduce using rule 36 (comparison_operator -> LT .)
    FLOAT           reduce using rule 36 (comparison_operator -> LT .)
    STRING          reduce using rule 36 (comparison_operator -> LT .)
    VARIABLE        reduce using rule 36 (comparison_operator -> LT .)
    LPAREN          reduce using rule 36 (comparison_operator -> LT .)


state 69

    (37) comparison_operator -> LE .

    INTEGER         reduce using rule 37 (comparison_operator -> LE .)
    FLOAT           reduce using rule 37 (comparison_operator -> LE .)
    STRING          reduce using rule 37 (comparison_operator -> LE .)
    VARIABLE        reduce using rule 37 (comparison_operator -> LE .)
    LPAREN          reduce using rule 37 (comparison_operator -> LE .)


state 70

    (38) comparison_operator -> GT .

    INTEGER         reduce using rule 38 (comparison_operator -> GT .)
    FLOAT           reduce using rule 38 (comparison_operator -> GT .)
    STRING          reduce using rule 38 (comparison_operator -> GT .)
    VARIABLE        reduce using rule 38 (comparison_operator -> GT .)
    LPAREN          reduce using rule 38 (comparison_operator -> GT .)


state 71

    (39) comparison_operator -> GE .

    INTEGER         reduce using rule 39 (comparison_operator -> GE .)
    FLOAT           reduce using rule 39 (comparison_operator -> GE .)
    STRING          reduce using rule 39 (comparison_operator -> GE .)
    VARIABLE        reduce using rule 39 (comparison_operator -> GE .)
    LPAREN          reduce using rule 39 (comparison_operator -> GE .)


state 72

    (28) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list . RPAREN LBRACE statement_list RBRACE
    (30) parameter_list -> parameter_list . COMMA VARIABLE

    RPAREN          shift and go to state 86
    COMMA           shift and go to state 87


state 73

    (29) parameter_list -> VARIABLE .

    RPAREN          reduce using rule 29 (parameter_list -> VARIABLE .)
    COMMA           reduce using rule 29 (parameter_list -> VARIABLE .)


state 74

    (31) parameter_list -> empty .

    RPAREN          reduce using rule 31 (parameter_list -> empty .)
    COMMA           reduce using rule 31 (parameter_list -> empty .)


state 75

    (23) class_statement -> CLASS IDENTIFIER LBRACE class_body . RBRACE
    (25) class_body -> class_body . class_body_element
    (26) class_body_element -> . assignment_statement
    (27) class_body_element -> . function_statement
    (17) assignment_statement -> . VARIABLE EQ expression SEMI
    (28) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    RBRACE          shift and go to state 88
    VARIABLE        shift and go to state 79
    FUNCTION        shift and go to state 18

    class_body_element             shift and go to state 89
    assignment_statement           shift and go to state 77
    function_statement             shift and go to state 78

state 76

    (24) class_body -> class_body_element .

    RBRACE          reduce using rule 24 (class_body -> class_body_element .)
    VARIABLE        reduce using rule 24 (class_body -> class_body_element .)
    FUNCTION        reduce using rule 24 (class_body -> class_body_element .)


state 77

    (26) class_body_element -> assignment_statement .

    RBRACE          reduce using rule 26 (class_body_element -> assignment_statement .)
    VARIABLE        reduce using rule 26 (class_body_element -> assignment_statement .)
    FUNCTION        reduce using rule 26 (class_body_element -> assignment_statement .)


state 78

    (27) class_body_element -> function_statement .

    RBRACE          reduce using rule 27 (class_body_element -> function_statement .)
    VARIABLE        reduce using rule 27 (class_body_element -> function_statement .)
    FUNCTION        reduce using rule 27 (class_body_element -> function_statement .)


state 79

    (17) assignment_statement -> VARIABLE . EQ expression SEMI

    EQ              shift and go to state 90


state 80

    (12) print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .

    IDENTIFIER      reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    VARIABLE        reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    IF              reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    FUNCTION        reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    CLASS           reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    INTEGER         reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    FLOAT           reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    STRING          reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    LPAREN          reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    $end            reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    ELSE            reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    RBRACE          reduce using rule 12 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)


state 81

    (15) argument_list -> argument_list COMMA expression .
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (46) expression -> expression . TIMES term
    (47) expression -> expression . DIVIDE term
    (48) expression -> expression . MOD term
    (49) expression -> expression . EXP term

    RPAREN          reduce using rule 15 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 15 (argument_list -> argument_list COMMA expression .)
    RBRACKET        reduce using rule 15 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    MOD             shift and go to state 33
    EXP             shift and go to state 34


state 82

    (22) array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET . SEMI

    SEMI            shift and go to state 91


state 83

    (18) condition_statement -> IF LPAREN condition RPAREN statement .
    (19) condition_statement -> IF LPAREN condition RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    IDENTIFIER      reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    VARIABLE        reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    IF              reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    FUNCTION        reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    CLASS           reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    INTEGER         reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    FLOAT           reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    STRING          reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    LPAREN          reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    $end            reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    RBRACE          reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .)
    ELSE            shift and go to state 92

  ! ELSE            [ reduce using rule 18 (condition_statement -> IF LPAREN condition RPAREN statement .) ]


state 84

    (33) condition -> condition logical_operator condition .
    (33) condition -> condition . logical_operator condition
    (40) logical_operator -> . AND
    (41) logical_operator -> . OR
    (42) logical_operator -> . NOT

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPAREN          reduce using rule 33 (condition -> condition logical_operator condition .)
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64

  ! AND             [ reduce using rule 33 (condition -> condition logical_operator condition .) ]
  ! OR              [ reduce using rule 33 (condition -> condition logical_operator condition .) ]
  ! NOT             [ reduce using rule 33 (condition -> condition logical_operator condition .) ]

    logical_operator               shift and go to state 61

state 85

    (32) condition -> expression comparison_operator expression .
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (46) expression -> expression . TIMES term
    (47) expression -> expression . DIVIDE term
    (48) expression -> expression . MOD term
    (49) expression -> expression . EXP term

    RPAREN          reduce using rule 32 (condition -> expression comparison_operator expression .)
    AND             reduce using rule 32 (condition -> expression comparison_operator expression .)
    OR              reduce using rule 32 (condition -> expression comparison_operator expression .)
    NOT             reduce using rule 32 (condition -> expression comparison_operator expression .)
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    MOD             shift and go to state 33
    EXP             shift and go to state 34


state 86

    (28) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 93


state 87

    (30) parameter_list -> parameter_list COMMA . VARIABLE

    VARIABLE        shift and go to state 94


state 88

    (23) class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .

    IDENTIFIER      reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    VARIABLE        reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    IF              reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    FUNCTION        reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    CLASS           reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    INTEGER         reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    FLOAT           reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    STRING          reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    LPAREN          reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    $end            reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    ELSE            reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 23 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)


state 89

    (25) class_body -> class_body class_body_element .

    RBRACE          reduce using rule 25 (class_body -> class_body class_body_element .)
    VARIABLE        reduce using rule 25 (class_body -> class_body class_body_element .)
    FUNCTION        reduce using rule 25 (class_body -> class_body class_body_element .)


state 90

    (17) assignment_statement -> VARIABLE EQ . expression SEMI
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    VARIABLE        shift and go to state 27
    LPAREN          shift and go to state 13

    expression                     shift and go to state 49
    term                           shift and go to state 20

state 91

    (22) array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .

    IDENTIFIER      reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    VARIABLE        reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    IF              reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    FUNCTION        reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    CLASS           reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    INTEGER         reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    FLOAT           reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    STRING          reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    LPAREN          reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    $end            reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    ELSE            reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    RBRACE          reduce using rule 22 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)


state 92

    (19) condition_statement -> IF LPAREN condition RPAREN statement ELSE . statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (13) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (16) expression_statement -> . expression SEMI
    (17) assignment_statement -> . VARIABLE EQ expression SEMI
    (18) condition_statement -> . IF LPAREN condition RPAREN statement
    (19) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (20) data_structure_statement -> . array_statement
    (21) data_structure_statement -> . class_statement
    (28) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (23) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (22) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 12
    VARIABLE        shift and go to state 15
    IF              shift and go to state 16
    FUNCTION        shift and go to state 18
    CLASS           shift and go to state 19
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    LPAREN          shift and go to state 13

    statement                      shift and go to state 95
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    expression                     shift and go to state 14
    array_statement                shift and go to state 17
    term                           shift and go to state 20

state 93

    (28) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE . statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (13) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (16) expression_statement -> . expression SEMI
    (17) assignment_statement -> . VARIABLE EQ expression SEMI
    (18) condition_statement -> . IF LPAREN condition RPAREN statement
    (19) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (20) data_structure_statement -> . array_statement
    (21) data_structure_statement -> . class_statement
    (28) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (23) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (22) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 12
    VARIABLE        shift and go to state 15
    IF              shift and go to state 16
    FUNCTION        shift and go to state 18
    CLASS           shift and go to state 19
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    LPAREN          shift and go to state 13

    statement_list                 shift and go to state 96
    statement                      shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    expression                     shift and go to state 14
    array_statement                shift and go to state 17
    term                           shift and go to state 20

state 94

    (30) parameter_list -> parameter_list COMMA VARIABLE .

    RPAREN          reduce using rule 30 (parameter_list -> parameter_list COMMA VARIABLE .)
    COMMA           reduce using rule 30 (parameter_list -> parameter_list COMMA VARIABLE .)


state 95

    (19) condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .

    IDENTIFIER      reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    VARIABLE        reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    IF              reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    FUNCTION        reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    CLASS           reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    INTEGER         reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    STRING          reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    $end            reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    ELSE            reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 19 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)


state 96

    (28) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list . RBRACE
    (3) statement_list -> statement_list . statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (13) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (16) expression_statement -> . expression SEMI
    (17) assignment_statement -> . VARIABLE EQ expression SEMI
    (18) condition_statement -> . IF LPAREN condition RPAREN statement
    (19) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (20) data_structure_statement -> . array_statement
    (21) data_structure_statement -> . class_statement
    (28) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (23) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (43) expression -> . term
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . expression TIMES term
    (47) expression -> . expression DIVIDE term
    (48) expression -> . expression MOD term
    (49) expression -> . expression EXP term
    (22) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (50) term -> . INTEGER
    (51) term -> . FLOAT
    (52) term -> . STRING
    (53) term -> . VARIABLE
    (54) term -> . LPAREN expression RPAREN

    RBRACE          shift and go to state 97
    IDENTIFIER      shift and go to state 12
    VARIABLE        shift and go to state 15
    IF              shift and go to state 16
    FUNCTION        shift and go to state 18
    CLASS           shift and go to state 19
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    LPAREN          shift and go to state 13

    statement                      shift and go to state 24
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    expression                     shift and go to state 14
    array_statement                shift and go to state 17
    term                           shift and go to state 20

state 97

    (28) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .

    IDENTIFIER      reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    VARIABLE        reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    FUNCTION        reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    INTEGER         reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    STRING          reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 28 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 83 resolved as shift
WARNING: shift/reduce conflict for AND in state 84 resolved as shift
WARNING: shift/reduce conflict for OR in state 84 resolved as shift
WARNING: shift/reduce conflict for NOT in state 84 resolved as shift
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> class_statement)
WARNING: rejected rule (data_structure_statement -> class_statement) in state 11
WARNING: Rule (data_structure_statement -> class_statement) is never reduced
