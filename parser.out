Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    CASE
    CATCH
    COMMENT
    CONST
    CONSTRUCT
    CONTINUE
    DEFAULT
    DO
    DOLLAR
    ELSEIF
    ERROR
    EXTENDS
    FINALLY
    FOR
    FOREACH
    IDENTICAL
    IMPLEMENTS
    NEW
    NEWLINE
    NOT_IDENTICAL
    PRIVATE
    PROTECTED
    PUBLIC
    RETURN
    SET
    STATIC
    SWITCH
    THROW
    TRY
    VAR
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> print_statement
Rule 5     statement -> input_statement
Rule 6     statement -> expression_statement
Rule 7     statement -> assignment_statement
Rule 8     statement -> condition_statement
Rule 9     statement -> data_structure_statement
Rule 10    statement -> function_statement
Rule 11    statement -> class_statement
Rule 12    statement -> ifStatement
Rule 13    statement -> array
Rule 14    print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI
Rule 15    input_statement -> IDENTIFIER LPAREN RPAREN SEMI
Rule 16    argument_list -> expression
Rule 17    argument_list -> argument_list COMMA expression
Rule 18    expression_statement -> expression SEMI
Rule 19    assignment_statement -> VARIABLE EQ expression SEMI
Rule 20    condition_statement -> IF LPAREN condition RPAREN statement
Rule 21    condition_statement -> IF LPAREN condition RPAREN statement ELSE statement
Rule 22    data_structure_statement -> array_statement
Rule 23    data_structure_statement -> class_statement
Rule 24    array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
Rule 25    class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE
Rule 26    class_body -> class_body_element
Rule 27    class_body -> class_body class_body_element
Rule 28    class_body_element -> assignment_statement
Rule 29    class_body_element -> function_statement
Rule 30    function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
Rule 31    parameter_list -> VARIABLE
Rule 32    parameter_list -> parameter_list COMMA VARIABLE
Rule 33    parameter_list -> empty
Rule 34    condition -> expression comparison_operator expression
Rule 35    condition -> condition logical_operator condition
Rule 36    array -> ARRAY LPAREN arrayArg RPAREN SEMI
Rule 37    arrayArg -> index ARROW value
Rule 38    arrayArg -> index ARROW value arrayArg
Rule 39    arrayArg -> index ARROW value COMMA arrayArg
Rule 40    index -> INTEGER
Rule 41    index -> STRING
Rule 42    ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI
Rule 43    ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement
Rule 44    elseStatement -> ELSE LBRACE statement RBRACE SEMI
Rule 45    value -> VARIABLE
Rule 46    value -> INTEGER
Rule 47    value -> FLOAT
Rule 48    value -> expression_statement
Rule 49    arrowFunction -> FUNCTION LPAREN VARIABLE RPAREN ARROW expression SEMI
Rule 50    arrowFunction -> FUNCTION LPAREN VARIABLE RPAREN ARROW arrowFunction
Rule 51    comparison_operator -> EQ
Rule 52    comparison_operator -> NE
Rule 53    comparison_operator -> LT
Rule 54    comparison_operator -> LE
Rule 55    comparison_operator -> GT
Rule 56    comparison_operator -> GE
Rule 57    logical_operator -> AND
Rule 58    logical_operator -> OR
Rule 59    logical_operator -> NOT
Rule 60    expression -> term
Rule 61    expression -> expression PLUS term
Rule 62    expression -> expression MINUS term
Rule 63    expression -> expression TIMES term
Rule 64    expression -> expression DIVIDE term
Rule 65    expression -> expression MOD term
Rule 66    expression -> expression EXP term
Rule 67    term -> INTEGER
Rule 68    term -> FLOAT
Rule 69    term -> STRING
Rule 70    term -> VARIABLE
Rule 71    term -> LPAREN expression RPAREN
Rule 72    empty -> <empty>

Terminals, with rules where they appear

AND                  : 57
ARRAY                : 36
ARROW                : 37 38 39 49 50
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 25
COMMA                : 17 32 39
COMMENT              : 
CONST                : 
CONSTRUCT            : 
CONTINUE             : 
DEFAULT              : 
DIVIDE               : 64
DO                   : 
DOLLAR               : 
ELSE                 : 21 44
ELSEIF               : 
EQ                   : 19 24 51
ERROR                : 
EXP                  : 66
EXTENDS              : 
FINALLY              : 
FLOAT                : 47 68
FOR                  : 
FOREACH              : 
FUNCTION             : 30 49 50
GE                   : 56
GT                   : 55
IDENTICAL            : 
IDENTIFIER           : 14 15 25 30
IF                   : 20 21 42 43
IMPLEMENTS           : 
INTEGER              : 40 46 67
LBRACE               : 25 30 42 43 44
LBRACKET             : 24
LE                   : 54
LPAREN               : 14 15 20 21 30 36 42 43 49 50 71
LT                   : 53
MINUS                : 62
MOD                  : 65
NE                   : 52
NEW                  : 
NEWLINE              : 
NOT                  : 59
NOT_IDENTICAL        : 
OR                   : 58
PLUS                 : 61
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
RBRACE               : 25 30 42 43 44
RBRACKET             : 24
RETURN               : 
RPAREN               : 14 15 20 21 30 36 42 43 49 50 71
SEMI                 : 14 15 18 19 24 36 42 44 49
SET                  : 
STATIC               : 
STRING               : 41 69
SWITCH               : 
THROW                : 
TIMES                : 63
TRY                  : 
VAR                  : 
VARIABLE             : 19 24 31 32 45 49 50 70
WHILE                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 14 17 24
array                : 13
arrayArg             : 36 38 39
array_statement      : 22
arrowFunction        : 50
assignment_statement : 7 28
class_body           : 25 27
class_body_element   : 26 27
class_statement      : 11 23
comparison_operator  : 34
condition            : 20 21 35 35 42 43
condition_statement  : 8
data_structure_statement : 9
elseStatement        : 43
empty                : 33
expression           : 16 17 18 19 34 34 49 61 62 63 64 65 66 71
expression_statement : 6 48
function_statement   : 10 29
ifStatement          : 12
index                : 37 38 39
input_statement      : 5
logical_operator     : 35
parameter_list       : 30 32
print_statement      : 4
program              : 0
statement            : 2 3 20 21 21 42 43 44
statement_list       : 1 3 30
term                 : 60 61 62 63 64 65 66
value                : 37 38 39

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) statement -> . ifStatement
    (13) statement -> . array
    (14) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (15) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (18) expression_statement -> . expression SEMI
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (20) condition_statement -> . IF LPAREN condition RPAREN statement
    (21) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (22) data_structure_statement -> . array_statement
    (23) data_structure_statement -> . class_statement
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (25) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (42) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement
    (36) array -> . ARRAY LPAREN arrayArg RPAREN SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (24) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 14
    VARIABLE        shift and go to state 17
    IF              shift and go to state 18
    FUNCTION        shift and go to state 20
    CLASS           shift and go to state 21
    ARRAY           shift and go to state 22
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    LPAREN          shift and go to state 15

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    ifStatement                    shift and go to state 12
    array                          shift and go to state 13
    expression                     shift and go to state 16
    array_statement                shift and go to state 19
    term                           shift and go to state 23

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) statement -> . ifStatement
    (13) statement -> . array
    (14) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (15) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (18) expression_statement -> . expression SEMI
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (20) condition_statement -> . IF LPAREN condition RPAREN statement
    (21) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (22) data_structure_statement -> . array_statement
    (23) data_structure_statement -> . class_statement
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (25) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (42) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement
    (36) array -> . ARRAY LPAREN arrayArg RPAREN SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (24) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    $end            reduce using rule 1 (program -> statement_list .)
    IDENTIFIER      shift and go to state 14
    VARIABLE        shift and go to state 17
    IF              shift and go to state 18
    FUNCTION        shift and go to state 20
    CLASS           shift and go to state 21
    ARRAY           shift and go to state 22
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    LPAREN          shift and go to state 15

    statement                      shift and go to state 27
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    ifStatement                    shift and go to state 12
    array                          shift and go to state 13
    expression                     shift and go to state 16
    array_statement                shift and go to state 19
    term                           shift and go to state 23

state 3

    (2) statement_list -> statement .

    IDENTIFIER      reduce using rule 2 (statement_list -> statement .)
    VARIABLE        reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    FUNCTION        reduce using rule 2 (statement_list -> statement .)
    CLASS           reduce using rule 2 (statement_list -> statement .)
    ARRAY           reduce using rule 2 (statement_list -> statement .)
    INTEGER         reduce using rule 2 (statement_list -> statement .)
    FLOAT           reduce using rule 2 (statement_list -> statement .)
    STRING          reduce using rule 2 (statement_list -> statement .)
    LPAREN          reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> print_statement .

    IDENTIFIER      reduce using rule 4 (statement -> print_statement .)
    VARIABLE        reduce using rule 4 (statement -> print_statement .)
    IF              reduce using rule 4 (statement -> print_statement .)
    FUNCTION        reduce using rule 4 (statement -> print_statement .)
    CLASS           reduce using rule 4 (statement -> print_statement .)
    ARRAY           reduce using rule 4 (statement -> print_statement .)
    INTEGER         reduce using rule 4 (statement -> print_statement .)
    FLOAT           reduce using rule 4 (statement -> print_statement .)
    STRING          reduce using rule 4 (statement -> print_statement .)
    LPAREN          reduce using rule 4 (statement -> print_statement .)
    $end            reduce using rule 4 (statement -> print_statement .)
    ELSE            reduce using rule 4 (statement -> print_statement .)
    RBRACE          reduce using rule 4 (statement -> print_statement .)


state 5

    (5) statement -> input_statement .

    IDENTIFIER      reduce using rule 5 (statement -> input_statement .)
    VARIABLE        reduce using rule 5 (statement -> input_statement .)
    IF              reduce using rule 5 (statement -> input_statement .)
    FUNCTION        reduce using rule 5 (statement -> input_statement .)
    CLASS           reduce using rule 5 (statement -> input_statement .)
    ARRAY           reduce using rule 5 (statement -> input_statement .)
    INTEGER         reduce using rule 5 (statement -> input_statement .)
    FLOAT           reduce using rule 5 (statement -> input_statement .)
    STRING          reduce using rule 5 (statement -> input_statement .)
    LPAREN          reduce using rule 5 (statement -> input_statement .)
    $end            reduce using rule 5 (statement -> input_statement .)
    ELSE            reduce using rule 5 (statement -> input_statement .)
    RBRACE          reduce using rule 5 (statement -> input_statement .)


state 6

    (6) statement -> expression_statement .

    IDENTIFIER      reduce using rule 6 (statement -> expression_statement .)
    VARIABLE        reduce using rule 6 (statement -> expression_statement .)
    IF              reduce using rule 6 (statement -> expression_statement .)
    FUNCTION        reduce using rule 6 (statement -> expression_statement .)
    CLASS           reduce using rule 6 (statement -> expression_statement .)
    ARRAY           reduce using rule 6 (statement -> expression_statement .)
    INTEGER         reduce using rule 6 (statement -> expression_statement .)
    FLOAT           reduce using rule 6 (statement -> expression_statement .)
    STRING          reduce using rule 6 (statement -> expression_statement .)
    LPAREN          reduce using rule 6 (statement -> expression_statement .)
    $end            reduce using rule 6 (statement -> expression_statement .)
    ELSE            reduce using rule 6 (statement -> expression_statement .)
    RBRACE          reduce using rule 6 (statement -> expression_statement .)


state 7

    (7) statement -> assignment_statement .

    IDENTIFIER      reduce using rule 7 (statement -> assignment_statement .)
    VARIABLE        reduce using rule 7 (statement -> assignment_statement .)
    IF              reduce using rule 7 (statement -> assignment_statement .)
    FUNCTION        reduce using rule 7 (statement -> assignment_statement .)
    CLASS           reduce using rule 7 (statement -> assignment_statement .)
    ARRAY           reduce using rule 7 (statement -> assignment_statement .)
    INTEGER         reduce using rule 7 (statement -> assignment_statement .)
    FLOAT           reduce using rule 7 (statement -> assignment_statement .)
    STRING          reduce using rule 7 (statement -> assignment_statement .)
    LPAREN          reduce using rule 7 (statement -> assignment_statement .)
    $end            reduce using rule 7 (statement -> assignment_statement .)
    ELSE            reduce using rule 7 (statement -> assignment_statement .)
    RBRACE          reduce using rule 7 (statement -> assignment_statement .)


state 8

    (8) statement -> condition_statement .

    IDENTIFIER      reduce using rule 8 (statement -> condition_statement .)
    VARIABLE        reduce using rule 8 (statement -> condition_statement .)
    IF              reduce using rule 8 (statement -> condition_statement .)
    FUNCTION        reduce using rule 8 (statement -> condition_statement .)
    CLASS           reduce using rule 8 (statement -> condition_statement .)
    ARRAY           reduce using rule 8 (statement -> condition_statement .)
    INTEGER         reduce using rule 8 (statement -> condition_statement .)
    FLOAT           reduce using rule 8 (statement -> condition_statement .)
    STRING          reduce using rule 8 (statement -> condition_statement .)
    LPAREN          reduce using rule 8 (statement -> condition_statement .)
    $end            reduce using rule 8 (statement -> condition_statement .)
    ELSE            reduce using rule 8 (statement -> condition_statement .)
    RBRACE          reduce using rule 8 (statement -> condition_statement .)


state 9

    (9) statement -> data_structure_statement .

    IDENTIFIER      reduce using rule 9 (statement -> data_structure_statement .)
    VARIABLE        reduce using rule 9 (statement -> data_structure_statement .)
    IF              reduce using rule 9 (statement -> data_structure_statement .)
    FUNCTION        reduce using rule 9 (statement -> data_structure_statement .)
    CLASS           reduce using rule 9 (statement -> data_structure_statement .)
    ARRAY           reduce using rule 9 (statement -> data_structure_statement .)
    INTEGER         reduce using rule 9 (statement -> data_structure_statement .)
    FLOAT           reduce using rule 9 (statement -> data_structure_statement .)
    STRING          reduce using rule 9 (statement -> data_structure_statement .)
    LPAREN          reduce using rule 9 (statement -> data_structure_statement .)
    $end            reduce using rule 9 (statement -> data_structure_statement .)
    ELSE            reduce using rule 9 (statement -> data_structure_statement .)
    RBRACE          reduce using rule 9 (statement -> data_structure_statement .)


state 10

    (10) statement -> function_statement .

    IDENTIFIER      reduce using rule 10 (statement -> function_statement .)
    VARIABLE        reduce using rule 10 (statement -> function_statement .)
    IF              reduce using rule 10 (statement -> function_statement .)
    FUNCTION        reduce using rule 10 (statement -> function_statement .)
    CLASS           reduce using rule 10 (statement -> function_statement .)
    ARRAY           reduce using rule 10 (statement -> function_statement .)
    INTEGER         reduce using rule 10 (statement -> function_statement .)
    FLOAT           reduce using rule 10 (statement -> function_statement .)
    STRING          reduce using rule 10 (statement -> function_statement .)
    LPAREN          reduce using rule 10 (statement -> function_statement .)
    $end            reduce using rule 10 (statement -> function_statement .)
    ELSE            reduce using rule 10 (statement -> function_statement .)
    RBRACE          reduce using rule 10 (statement -> function_statement .)


state 11

    (11) statement -> class_statement .
    (23) data_structure_statement -> class_statement .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for IF resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for CLASS resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for ARRAY resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for INTEGER resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for STRING resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 11 (statement -> class_statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 11 (statement -> class_statement .)
    IDENTIFIER      reduce using rule 11 (statement -> class_statement .)
    VARIABLE        reduce using rule 11 (statement -> class_statement .)
    IF              reduce using rule 11 (statement -> class_statement .)
    FUNCTION        reduce using rule 11 (statement -> class_statement .)
    CLASS           reduce using rule 11 (statement -> class_statement .)
    ARRAY           reduce using rule 11 (statement -> class_statement .)
    INTEGER         reduce using rule 11 (statement -> class_statement .)
    FLOAT           reduce using rule 11 (statement -> class_statement .)
    STRING          reduce using rule 11 (statement -> class_statement .)
    LPAREN          reduce using rule 11 (statement -> class_statement .)
    $end            reduce using rule 11 (statement -> class_statement .)
    ELSE            reduce using rule 11 (statement -> class_statement .)
    RBRACE          reduce using rule 11 (statement -> class_statement .)

  ! IDENTIFIER      [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! VARIABLE        [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! IF              [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! FUNCTION        [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! CLASS           [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! ARRAY           [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! INTEGER         [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! FLOAT           [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! STRING          [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! LPAREN          [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! $end            [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! ELSE            [ reduce using rule 23 (data_structure_statement -> class_statement .) ]
  ! RBRACE          [ reduce using rule 23 (data_structure_statement -> class_statement .) ]


state 12

    (12) statement -> ifStatement .

    IDENTIFIER      reduce using rule 12 (statement -> ifStatement .)
    VARIABLE        reduce using rule 12 (statement -> ifStatement .)
    IF              reduce using rule 12 (statement -> ifStatement .)
    FUNCTION        reduce using rule 12 (statement -> ifStatement .)
    CLASS           reduce using rule 12 (statement -> ifStatement .)
    ARRAY           reduce using rule 12 (statement -> ifStatement .)
    INTEGER         reduce using rule 12 (statement -> ifStatement .)
    FLOAT           reduce using rule 12 (statement -> ifStatement .)
    STRING          reduce using rule 12 (statement -> ifStatement .)
    LPAREN          reduce using rule 12 (statement -> ifStatement .)
    $end            reduce using rule 12 (statement -> ifStatement .)
    ELSE            reduce using rule 12 (statement -> ifStatement .)
    RBRACE          reduce using rule 12 (statement -> ifStatement .)


state 13

    (13) statement -> array .

    IDENTIFIER      reduce using rule 13 (statement -> array .)
    VARIABLE        reduce using rule 13 (statement -> array .)
    IF              reduce using rule 13 (statement -> array .)
    FUNCTION        reduce using rule 13 (statement -> array .)
    CLASS           reduce using rule 13 (statement -> array .)
    ARRAY           reduce using rule 13 (statement -> array .)
    INTEGER         reduce using rule 13 (statement -> array .)
    FLOAT           reduce using rule 13 (statement -> array .)
    STRING          reduce using rule 13 (statement -> array .)
    LPAREN          reduce using rule 13 (statement -> array .)
    $end            reduce using rule 13 (statement -> array .)
    ELSE            reduce using rule 13 (statement -> array .)
    RBRACE          reduce using rule 13 (statement -> array .)


state 14

    (14) print_statement -> IDENTIFIER . LPAREN argument_list RPAREN SEMI
    (15) input_statement -> IDENTIFIER . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 28


state 15

    (71) term -> LPAREN . expression RPAREN
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    expression                     shift and go to state 29
    term                           shift and go to state 23

state 16

    (18) expression_statement -> expression . SEMI
    (61) expression -> expression . PLUS term
    (62) expression -> expression . MINUS term
    (63) expression -> expression . TIMES term
    (64) expression -> expression . DIVIDE term
    (65) expression -> expression . MOD term
    (66) expression -> expression . EXP term

    SEMI            shift and go to state 31
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36
    EXP             shift and go to state 37


state 17

    (19) assignment_statement -> VARIABLE . EQ expression SEMI
    (24) array_statement -> VARIABLE . EQ LBRACKET argument_list RBRACKET SEMI
    (70) term -> VARIABLE .

    EQ              shift and go to state 38
    SEMI            reduce using rule 70 (term -> VARIABLE .)
    PLUS            reduce using rule 70 (term -> VARIABLE .)
    MINUS           reduce using rule 70 (term -> VARIABLE .)
    TIMES           reduce using rule 70 (term -> VARIABLE .)
    DIVIDE          reduce using rule 70 (term -> VARIABLE .)
    MOD             reduce using rule 70 (term -> VARIABLE .)
    EXP             reduce using rule 70 (term -> VARIABLE .)


state 18

    (20) condition_statement -> IF . LPAREN condition RPAREN statement
    (21) condition_statement -> IF . LPAREN condition RPAREN statement ELSE statement
    (42) ifStatement -> IF . LPAREN condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> IF . LPAREN condition RPAREN LBRACE statement RBRACE elseStatement

    LPAREN          shift and go to state 39


state 19

    (22) data_structure_statement -> array_statement .

    IDENTIFIER      reduce using rule 22 (data_structure_statement -> array_statement .)
    VARIABLE        reduce using rule 22 (data_structure_statement -> array_statement .)
    IF              reduce using rule 22 (data_structure_statement -> array_statement .)
    FUNCTION        reduce using rule 22 (data_structure_statement -> array_statement .)
    CLASS           reduce using rule 22 (data_structure_statement -> array_statement .)
    ARRAY           reduce using rule 22 (data_structure_statement -> array_statement .)
    INTEGER         reduce using rule 22 (data_structure_statement -> array_statement .)
    FLOAT           reduce using rule 22 (data_structure_statement -> array_statement .)
    STRING          reduce using rule 22 (data_structure_statement -> array_statement .)
    LPAREN          reduce using rule 22 (data_structure_statement -> array_statement .)
    $end            reduce using rule 22 (data_structure_statement -> array_statement .)
    ELSE            reduce using rule 22 (data_structure_statement -> array_statement .)
    RBRACE          reduce using rule 22 (data_structure_statement -> array_statement .)


state 20

    (30) function_statement -> FUNCTION . IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    IDENTIFIER      shift and go to state 40


state 21

    (25) class_statement -> CLASS . IDENTIFIER LBRACE class_body RBRACE

    IDENTIFIER      shift and go to state 41


state 22

    (36) array -> ARRAY . LPAREN arrayArg RPAREN SEMI

    LPAREN          shift and go to state 42


state 23

    (60) expression -> term .

    SEMI            reduce using rule 60 (expression -> term .)
    PLUS            reduce using rule 60 (expression -> term .)
    MINUS           reduce using rule 60 (expression -> term .)
    TIMES           reduce using rule 60 (expression -> term .)
    DIVIDE          reduce using rule 60 (expression -> term .)
    MOD             reduce using rule 60 (expression -> term .)
    EXP             reduce using rule 60 (expression -> term .)
    RPAREN          reduce using rule 60 (expression -> term .)
    COMMA           reduce using rule 60 (expression -> term .)
    EQ              reduce using rule 60 (expression -> term .)
    NE              reduce using rule 60 (expression -> term .)
    LT              reduce using rule 60 (expression -> term .)
    LE              reduce using rule 60 (expression -> term .)
    GT              reduce using rule 60 (expression -> term .)
    GE              reduce using rule 60 (expression -> term .)
    RBRACKET        reduce using rule 60 (expression -> term .)
    AND             reduce using rule 60 (expression -> term .)
    OR              reduce using rule 60 (expression -> term .)
    NOT             reduce using rule 60 (expression -> term .)


state 24

    (67) term -> INTEGER .

    SEMI            reduce using rule 67 (term -> INTEGER .)
    PLUS            reduce using rule 67 (term -> INTEGER .)
    MINUS           reduce using rule 67 (term -> INTEGER .)
    TIMES           reduce using rule 67 (term -> INTEGER .)
    DIVIDE          reduce using rule 67 (term -> INTEGER .)
    MOD             reduce using rule 67 (term -> INTEGER .)
    EXP             reduce using rule 67 (term -> INTEGER .)
    RPAREN          reduce using rule 67 (term -> INTEGER .)
    COMMA           reduce using rule 67 (term -> INTEGER .)
    EQ              reduce using rule 67 (term -> INTEGER .)
    NE              reduce using rule 67 (term -> INTEGER .)
    LT              reduce using rule 67 (term -> INTEGER .)
    LE              reduce using rule 67 (term -> INTEGER .)
    GT              reduce using rule 67 (term -> INTEGER .)
    GE              reduce using rule 67 (term -> INTEGER .)
    RBRACKET        reduce using rule 67 (term -> INTEGER .)
    AND             reduce using rule 67 (term -> INTEGER .)
    OR              reduce using rule 67 (term -> INTEGER .)
    NOT             reduce using rule 67 (term -> INTEGER .)


state 25

    (68) term -> FLOAT .

    SEMI            reduce using rule 68 (term -> FLOAT .)
    PLUS            reduce using rule 68 (term -> FLOAT .)
    MINUS           reduce using rule 68 (term -> FLOAT .)
    TIMES           reduce using rule 68 (term -> FLOAT .)
    DIVIDE          reduce using rule 68 (term -> FLOAT .)
    MOD             reduce using rule 68 (term -> FLOAT .)
    EXP             reduce using rule 68 (term -> FLOAT .)
    RPAREN          reduce using rule 68 (term -> FLOAT .)
    COMMA           reduce using rule 68 (term -> FLOAT .)
    EQ              reduce using rule 68 (term -> FLOAT .)
    NE              reduce using rule 68 (term -> FLOAT .)
    LT              reduce using rule 68 (term -> FLOAT .)
    LE              reduce using rule 68 (term -> FLOAT .)
    GT              reduce using rule 68 (term -> FLOAT .)
    GE              reduce using rule 68 (term -> FLOAT .)
    RBRACKET        reduce using rule 68 (term -> FLOAT .)
    AND             reduce using rule 68 (term -> FLOAT .)
    OR              reduce using rule 68 (term -> FLOAT .)
    NOT             reduce using rule 68 (term -> FLOAT .)


state 26

    (69) term -> STRING .

    SEMI            reduce using rule 69 (term -> STRING .)
    PLUS            reduce using rule 69 (term -> STRING .)
    MINUS           reduce using rule 69 (term -> STRING .)
    TIMES           reduce using rule 69 (term -> STRING .)
    DIVIDE          reduce using rule 69 (term -> STRING .)
    MOD             reduce using rule 69 (term -> STRING .)
    EXP             reduce using rule 69 (term -> STRING .)
    RPAREN          reduce using rule 69 (term -> STRING .)
    COMMA           reduce using rule 69 (term -> STRING .)
    EQ              reduce using rule 69 (term -> STRING .)
    NE              reduce using rule 69 (term -> STRING .)
    LT              reduce using rule 69 (term -> STRING .)
    LE              reduce using rule 69 (term -> STRING .)
    GT              reduce using rule 69 (term -> STRING .)
    GE              reduce using rule 69 (term -> STRING .)
    RBRACKET        reduce using rule 69 (term -> STRING .)
    AND             reduce using rule 69 (term -> STRING .)
    OR              reduce using rule 69 (term -> STRING .)
    NOT             reduce using rule 69 (term -> STRING .)


state 27

    (3) statement_list -> statement_list statement .

    IDENTIFIER      reduce using rule 3 (statement_list -> statement_list statement .)
    VARIABLE        reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    FUNCTION        reduce using rule 3 (statement_list -> statement_list statement .)
    CLASS           reduce using rule 3 (statement_list -> statement_list statement .)
    ARRAY           reduce using rule 3 (statement_list -> statement_list statement .)
    INTEGER         reduce using rule 3 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 3 (statement_list -> statement_list statement .)
    STRING          reduce using rule 3 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement_list statement .)


state 28

    (14) print_statement -> IDENTIFIER LPAREN . argument_list RPAREN SEMI
    (15) input_statement -> IDENTIFIER LPAREN . RPAREN SEMI
    (16) argument_list -> . expression
    (17) argument_list -> . argument_list COMMA expression
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    RPAREN          shift and go to state 44
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    argument_list                  shift and go to state 43
    expression                     shift and go to state 45
    term                           shift and go to state 23

state 29

    (71) term -> LPAREN expression . RPAREN
    (61) expression -> expression . PLUS term
    (62) expression -> expression . MINUS term
    (63) expression -> expression . TIMES term
    (64) expression -> expression . DIVIDE term
    (65) expression -> expression . MOD term
    (66) expression -> expression . EXP term

    RPAREN          shift and go to state 46
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36
    EXP             shift and go to state 37


state 30

    (70) term -> VARIABLE .

    RPAREN          reduce using rule 70 (term -> VARIABLE .)
    PLUS            reduce using rule 70 (term -> VARIABLE .)
    MINUS           reduce using rule 70 (term -> VARIABLE .)
    TIMES           reduce using rule 70 (term -> VARIABLE .)
    DIVIDE          reduce using rule 70 (term -> VARIABLE .)
    MOD             reduce using rule 70 (term -> VARIABLE .)
    EXP             reduce using rule 70 (term -> VARIABLE .)
    COMMA           reduce using rule 70 (term -> VARIABLE .)
    SEMI            reduce using rule 70 (term -> VARIABLE .)
    EQ              reduce using rule 70 (term -> VARIABLE .)
    NE              reduce using rule 70 (term -> VARIABLE .)
    LT              reduce using rule 70 (term -> VARIABLE .)
    LE              reduce using rule 70 (term -> VARIABLE .)
    GT              reduce using rule 70 (term -> VARIABLE .)
    GE              reduce using rule 70 (term -> VARIABLE .)
    RBRACKET        reduce using rule 70 (term -> VARIABLE .)
    AND             reduce using rule 70 (term -> VARIABLE .)
    OR              reduce using rule 70 (term -> VARIABLE .)
    NOT             reduce using rule 70 (term -> VARIABLE .)


state 31

    (18) expression_statement -> expression SEMI .

    IDENTIFIER      reduce using rule 18 (expression_statement -> expression SEMI .)
    VARIABLE        reduce using rule 18 (expression_statement -> expression SEMI .)
    IF              reduce using rule 18 (expression_statement -> expression SEMI .)
    FUNCTION        reduce using rule 18 (expression_statement -> expression SEMI .)
    CLASS           reduce using rule 18 (expression_statement -> expression SEMI .)
    ARRAY           reduce using rule 18 (expression_statement -> expression SEMI .)
    INTEGER         reduce using rule 18 (expression_statement -> expression SEMI .)
    FLOAT           reduce using rule 18 (expression_statement -> expression SEMI .)
    STRING          reduce using rule 18 (expression_statement -> expression SEMI .)
    LPAREN          reduce using rule 18 (expression_statement -> expression SEMI .)
    $end            reduce using rule 18 (expression_statement -> expression SEMI .)
    ELSE            reduce using rule 18 (expression_statement -> expression SEMI .)
    RBRACE          reduce using rule 18 (expression_statement -> expression SEMI .)
    COMMA           reduce using rule 18 (expression_statement -> expression SEMI .)
    RPAREN          reduce using rule 18 (expression_statement -> expression SEMI .)


state 32

    (61) expression -> expression PLUS . term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    term                           shift and go to state 47

state 33

    (62) expression -> expression MINUS . term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    term                           shift and go to state 48

state 34

    (63) expression -> expression TIMES . term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    term                           shift and go to state 49

state 35

    (64) expression -> expression DIVIDE . term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    term                           shift and go to state 50

state 36

    (65) expression -> expression MOD . term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    term                           shift and go to state 51

state 37

    (66) expression -> expression EXP . term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    term                           shift and go to state 52

state 38

    (19) assignment_statement -> VARIABLE EQ . expression SEMI
    (24) array_statement -> VARIABLE EQ . LBRACKET argument_list RBRACKET SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    LBRACKET        shift and go to state 54
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    expression                     shift and go to state 53
    term                           shift and go to state 23

state 39

    (20) condition_statement -> IF LPAREN . condition RPAREN statement
    (21) condition_statement -> IF LPAREN . condition RPAREN statement ELSE statement
    (42) ifStatement -> IF LPAREN . condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> IF LPAREN . condition RPAREN LBRACE statement RBRACE elseStatement
    (34) condition -> . expression comparison_operator expression
    (35) condition -> . condition logical_operator condition
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    condition                      shift and go to state 55
    expression                     shift and go to state 56
    term                           shift and go to state 23

state 40

    (30) function_statement -> FUNCTION IDENTIFIER . LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    LPAREN          shift and go to state 57


state 41

    (25) class_statement -> CLASS IDENTIFIER . LBRACE class_body RBRACE

    LBRACE          shift and go to state 58


state 42

    (36) array -> ARRAY LPAREN . arrayArg RPAREN SEMI
    (37) arrayArg -> . index ARROW value
    (38) arrayArg -> . index ARROW value arrayArg
    (39) arrayArg -> . index ARROW value COMMA arrayArg
    (40) index -> . INTEGER
    (41) index -> . STRING

    INTEGER         shift and go to state 61
    STRING          shift and go to state 62

    arrayArg                       shift and go to state 59
    index                          shift and go to state 60

state 43

    (14) print_statement -> IDENTIFIER LPAREN argument_list . RPAREN SEMI
    (17) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 63
    COMMA           shift and go to state 64


state 44

    (15) input_statement -> IDENTIFIER LPAREN RPAREN . SEMI

    SEMI            shift and go to state 65


state 45

    (16) argument_list -> expression .
    (61) expression -> expression . PLUS term
    (62) expression -> expression . MINUS term
    (63) expression -> expression . TIMES term
    (64) expression -> expression . DIVIDE term
    (65) expression -> expression . MOD term
    (66) expression -> expression . EXP term

    RPAREN          reduce using rule 16 (argument_list -> expression .)
    COMMA           reduce using rule 16 (argument_list -> expression .)
    RBRACKET        reduce using rule 16 (argument_list -> expression .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36
    EXP             shift and go to state 37


state 46

    (71) term -> LPAREN expression RPAREN .

    SEMI            reduce using rule 71 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 71 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 71 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 71 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 71 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 71 (term -> LPAREN expression RPAREN .)
    EXP             reduce using rule 71 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 71 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 71 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    NE              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    LE              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    GE              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 71 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 71 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    NOT             reduce using rule 71 (term -> LPAREN expression RPAREN .)


state 47

    (61) expression -> expression PLUS term .

    SEMI            reduce using rule 61 (expression -> expression PLUS term .)
    PLUS            reduce using rule 61 (expression -> expression PLUS term .)
    MINUS           reduce using rule 61 (expression -> expression PLUS term .)
    TIMES           reduce using rule 61 (expression -> expression PLUS term .)
    DIVIDE          reduce using rule 61 (expression -> expression PLUS term .)
    MOD             reduce using rule 61 (expression -> expression PLUS term .)
    EXP             reduce using rule 61 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 61 (expression -> expression PLUS term .)
    COMMA           reduce using rule 61 (expression -> expression PLUS term .)
    EQ              reduce using rule 61 (expression -> expression PLUS term .)
    NE              reduce using rule 61 (expression -> expression PLUS term .)
    LT              reduce using rule 61 (expression -> expression PLUS term .)
    LE              reduce using rule 61 (expression -> expression PLUS term .)
    GT              reduce using rule 61 (expression -> expression PLUS term .)
    GE              reduce using rule 61 (expression -> expression PLUS term .)
    RBRACKET        reduce using rule 61 (expression -> expression PLUS term .)
    AND             reduce using rule 61 (expression -> expression PLUS term .)
    OR              reduce using rule 61 (expression -> expression PLUS term .)
    NOT             reduce using rule 61 (expression -> expression PLUS term .)


state 48

    (62) expression -> expression MINUS term .

    SEMI            reduce using rule 62 (expression -> expression MINUS term .)
    PLUS            reduce using rule 62 (expression -> expression MINUS term .)
    MINUS           reduce using rule 62 (expression -> expression MINUS term .)
    TIMES           reduce using rule 62 (expression -> expression MINUS term .)
    DIVIDE          reduce using rule 62 (expression -> expression MINUS term .)
    MOD             reduce using rule 62 (expression -> expression MINUS term .)
    EXP             reduce using rule 62 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 62 (expression -> expression MINUS term .)
    COMMA           reduce using rule 62 (expression -> expression MINUS term .)
    EQ              reduce using rule 62 (expression -> expression MINUS term .)
    NE              reduce using rule 62 (expression -> expression MINUS term .)
    LT              reduce using rule 62 (expression -> expression MINUS term .)
    LE              reduce using rule 62 (expression -> expression MINUS term .)
    GT              reduce using rule 62 (expression -> expression MINUS term .)
    GE              reduce using rule 62 (expression -> expression MINUS term .)
    RBRACKET        reduce using rule 62 (expression -> expression MINUS term .)
    AND             reduce using rule 62 (expression -> expression MINUS term .)
    OR              reduce using rule 62 (expression -> expression MINUS term .)
    NOT             reduce using rule 62 (expression -> expression MINUS term .)


state 49

    (63) expression -> expression TIMES term .

    SEMI            reduce using rule 63 (expression -> expression TIMES term .)
    PLUS            reduce using rule 63 (expression -> expression TIMES term .)
    MINUS           reduce using rule 63 (expression -> expression TIMES term .)
    TIMES           reduce using rule 63 (expression -> expression TIMES term .)
    DIVIDE          reduce using rule 63 (expression -> expression TIMES term .)
    MOD             reduce using rule 63 (expression -> expression TIMES term .)
    EXP             reduce using rule 63 (expression -> expression TIMES term .)
    RPAREN          reduce using rule 63 (expression -> expression TIMES term .)
    COMMA           reduce using rule 63 (expression -> expression TIMES term .)
    EQ              reduce using rule 63 (expression -> expression TIMES term .)
    NE              reduce using rule 63 (expression -> expression TIMES term .)
    LT              reduce using rule 63 (expression -> expression TIMES term .)
    LE              reduce using rule 63 (expression -> expression TIMES term .)
    GT              reduce using rule 63 (expression -> expression TIMES term .)
    GE              reduce using rule 63 (expression -> expression TIMES term .)
    RBRACKET        reduce using rule 63 (expression -> expression TIMES term .)
    AND             reduce using rule 63 (expression -> expression TIMES term .)
    OR              reduce using rule 63 (expression -> expression TIMES term .)
    NOT             reduce using rule 63 (expression -> expression TIMES term .)


state 50

    (64) expression -> expression DIVIDE term .

    SEMI            reduce using rule 64 (expression -> expression DIVIDE term .)
    PLUS            reduce using rule 64 (expression -> expression DIVIDE term .)
    MINUS           reduce using rule 64 (expression -> expression DIVIDE term .)
    TIMES           reduce using rule 64 (expression -> expression DIVIDE term .)
    DIVIDE          reduce using rule 64 (expression -> expression DIVIDE term .)
    MOD             reduce using rule 64 (expression -> expression DIVIDE term .)
    EXP             reduce using rule 64 (expression -> expression DIVIDE term .)
    RPAREN          reduce using rule 64 (expression -> expression DIVIDE term .)
    COMMA           reduce using rule 64 (expression -> expression DIVIDE term .)
    EQ              reduce using rule 64 (expression -> expression DIVIDE term .)
    NE              reduce using rule 64 (expression -> expression DIVIDE term .)
    LT              reduce using rule 64 (expression -> expression DIVIDE term .)
    LE              reduce using rule 64 (expression -> expression DIVIDE term .)
    GT              reduce using rule 64 (expression -> expression DIVIDE term .)
    GE              reduce using rule 64 (expression -> expression DIVIDE term .)
    RBRACKET        reduce using rule 64 (expression -> expression DIVIDE term .)
    AND             reduce using rule 64 (expression -> expression DIVIDE term .)
    OR              reduce using rule 64 (expression -> expression DIVIDE term .)
    NOT             reduce using rule 64 (expression -> expression DIVIDE term .)


state 51

    (65) expression -> expression MOD term .

    SEMI            reduce using rule 65 (expression -> expression MOD term .)
    PLUS            reduce using rule 65 (expression -> expression MOD term .)
    MINUS           reduce using rule 65 (expression -> expression MOD term .)
    TIMES           reduce using rule 65 (expression -> expression MOD term .)
    DIVIDE          reduce using rule 65 (expression -> expression MOD term .)
    MOD             reduce using rule 65 (expression -> expression MOD term .)
    EXP             reduce using rule 65 (expression -> expression MOD term .)
    RPAREN          reduce using rule 65 (expression -> expression MOD term .)
    COMMA           reduce using rule 65 (expression -> expression MOD term .)
    EQ              reduce using rule 65 (expression -> expression MOD term .)
    NE              reduce using rule 65 (expression -> expression MOD term .)
    LT              reduce using rule 65 (expression -> expression MOD term .)
    LE              reduce using rule 65 (expression -> expression MOD term .)
    GT              reduce using rule 65 (expression -> expression MOD term .)
    GE              reduce using rule 65 (expression -> expression MOD term .)
    RBRACKET        reduce using rule 65 (expression -> expression MOD term .)
    AND             reduce using rule 65 (expression -> expression MOD term .)
    OR              reduce using rule 65 (expression -> expression MOD term .)
    NOT             reduce using rule 65 (expression -> expression MOD term .)


state 52

    (66) expression -> expression EXP term .

    SEMI            reduce using rule 66 (expression -> expression EXP term .)
    PLUS            reduce using rule 66 (expression -> expression EXP term .)
    MINUS           reduce using rule 66 (expression -> expression EXP term .)
    TIMES           reduce using rule 66 (expression -> expression EXP term .)
    DIVIDE          reduce using rule 66 (expression -> expression EXP term .)
    MOD             reduce using rule 66 (expression -> expression EXP term .)
    EXP             reduce using rule 66 (expression -> expression EXP term .)
    RPAREN          reduce using rule 66 (expression -> expression EXP term .)
    COMMA           reduce using rule 66 (expression -> expression EXP term .)
    EQ              reduce using rule 66 (expression -> expression EXP term .)
    NE              reduce using rule 66 (expression -> expression EXP term .)
    LT              reduce using rule 66 (expression -> expression EXP term .)
    LE              reduce using rule 66 (expression -> expression EXP term .)
    GT              reduce using rule 66 (expression -> expression EXP term .)
    GE              reduce using rule 66 (expression -> expression EXP term .)
    RBRACKET        reduce using rule 66 (expression -> expression EXP term .)
    AND             reduce using rule 66 (expression -> expression EXP term .)
    OR              reduce using rule 66 (expression -> expression EXP term .)
    NOT             reduce using rule 66 (expression -> expression EXP term .)


state 53

    (19) assignment_statement -> VARIABLE EQ expression . SEMI
    (61) expression -> expression . PLUS term
    (62) expression -> expression . MINUS term
    (63) expression -> expression . TIMES term
    (64) expression -> expression . DIVIDE term
    (65) expression -> expression . MOD term
    (66) expression -> expression . EXP term

    SEMI            shift and go to state 66
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36
    EXP             shift and go to state 37


state 54

    (24) array_statement -> VARIABLE EQ LBRACKET . argument_list RBRACKET SEMI
    (16) argument_list -> . expression
    (17) argument_list -> . argument_list COMMA expression
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    argument_list                  shift and go to state 67
    expression                     shift and go to state 45
    term                           shift and go to state 23

state 55

    (20) condition_statement -> IF LPAREN condition . RPAREN statement
    (21) condition_statement -> IF LPAREN condition . RPAREN statement ELSE statement
    (42) ifStatement -> IF LPAREN condition . RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> IF LPAREN condition . RPAREN LBRACE statement RBRACE elseStatement
    (35) condition -> condition . logical_operator condition
    (57) logical_operator -> . AND
    (58) logical_operator -> . OR
    (59) logical_operator -> . NOT

    RPAREN          shift and go to state 68
    AND             shift and go to state 70
    OR              shift and go to state 71
    NOT             shift and go to state 72

    logical_operator               shift and go to state 69

state 56

    (34) condition -> expression . comparison_operator expression
    (61) expression -> expression . PLUS term
    (62) expression -> expression . MINUS term
    (63) expression -> expression . TIMES term
    (64) expression -> expression . DIVIDE term
    (65) expression -> expression . MOD term
    (66) expression -> expression . EXP term
    (51) comparison_operator -> . EQ
    (52) comparison_operator -> . NE
    (53) comparison_operator -> . LT
    (54) comparison_operator -> . LE
    (55) comparison_operator -> . GT
    (56) comparison_operator -> . GE

    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36
    EXP             shift and go to state 37
    EQ              shift and go to state 74
    NE              shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79

    comparison_operator            shift and go to state 73

state 57

    (30) function_statement -> FUNCTION IDENTIFIER LPAREN . parameter_list RPAREN LBRACE statement_list RBRACE
    (31) parameter_list -> . VARIABLE
    (32) parameter_list -> . parameter_list COMMA VARIABLE
    (33) parameter_list -> . empty
    (72) empty -> .

    VARIABLE        shift and go to state 81
    RPAREN          reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

    parameter_list                 shift and go to state 80
    empty                          shift and go to state 82

state 58

    (25) class_statement -> CLASS IDENTIFIER LBRACE . class_body RBRACE
    (26) class_body -> . class_body_element
    (27) class_body -> . class_body class_body_element
    (28) class_body_element -> . assignment_statement
    (29) class_body_element -> . function_statement
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    VARIABLE        shift and go to state 87
    FUNCTION        shift and go to state 20

    class_body                     shift and go to state 83
    class_body_element             shift and go to state 84
    assignment_statement           shift and go to state 85
    function_statement             shift and go to state 86

state 59

    (36) array -> ARRAY LPAREN arrayArg . RPAREN SEMI

    RPAREN          shift and go to state 88


state 60

    (37) arrayArg -> index . ARROW value
    (38) arrayArg -> index . ARROW value arrayArg
    (39) arrayArg -> index . ARROW value COMMA arrayArg

    ARROW           shift and go to state 89


state 61

    (40) index -> INTEGER .

    ARROW           reduce using rule 40 (index -> INTEGER .)


state 62

    (41) index -> STRING .

    ARROW           reduce using rule 41 (index -> STRING .)


state 63

    (14) print_statement -> IDENTIFIER LPAREN argument_list RPAREN . SEMI

    SEMI            shift and go to state 90


state 64

    (17) argument_list -> argument_list COMMA . expression
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    expression                     shift and go to state 91
    term                           shift and go to state 23

state 65

    (15) input_statement -> IDENTIFIER LPAREN RPAREN SEMI .

    IDENTIFIER      reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    VARIABLE        reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    IF              reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    FUNCTION        reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    CLASS           reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    ARRAY           reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    INTEGER         reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    FLOAT           reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    STRING          reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    LPAREN          reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    $end            reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    ELSE            reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)
    RBRACE          reduce using rule 15 (input_statement -> IDENTIFIER LPAREN RPAREN SEMI .)


state 66

    (19) assignment_statement -> VARIABLE EQ expression SEMI .

    IDENTIFIER      reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    VARIABLE        reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    IF              reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    FUNCTION        reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    CLASS           reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    ARRAY           reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    INTEGER         reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    FLOAT           reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    STRING          reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    LPAREN          reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    $end            reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    RBRACE          reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)
    ELSE            reduce using rule 19 (assignment_statement -> VARIABLE EQ expression SEMI .)


state 67

    (24) array_statement -> VARIABLE EQ LBRACKET argument_list . RBRACKET SEMI
    (17) argument_list -> argument_list . COMMA expression

    RBRACKET        shift and go to state 92
    COMMA           shift and go to state 64


state 68

    (20) condition_statement -> IF LPAREN condition RPAREN . statement
    (21) condition_statement -> IF LPAREN condition RPAREN . statement ELSE statement
    (42) ifStatement -> IF LPAREN condition RPAREN . LBRACE statement RBRACE SEMI
    (43) ifStatement -> IF LPAREN condition RPAREN . LBRACE statement RBRACE elseStatement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) statement -> . ifStatement
    (13) statement -> . array
    (14) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (15) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (18) expression_statement -> . expression SEMI
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (20) condition_statement -> . IF LPAREN condition RPAREN statement
    (21) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (22) data_structure_statement -> . array_statement
    (23) data_structure_statement -> . class_statement
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (25) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (42) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement
    (36) array -> . ARRAY LPAREN arrayArg RPAREN SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (24) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    LBRACE          shift and go to state 94
    IDENTIFIER      shift and go to state 14
    VARIABLE        shift and go to state 17
    IF              shift and go to state 18
    FUNCTION        shift and go to state 20
    CLASS           shift and go to state 21
    ARRAY           shift and go to state 22
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    LPAREN          shift and go to state 15

    statement                      shift and go to state 93
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    ifStatement                    shift and go to state 12
    array                          shift and go to state 13
    expression                     shift and go to state 16
    array_statement                shift and go to state 19
    term                           shift and go to state 23

state 69

    (35) condition -> condition logical_operator . condition
    (34) condition -> . expression comparison_operator expression
    (35) condition -> . condition logical_operator condition
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    condition                      shift and go to state 95
    expression                     shift and go to state 56
    term                           shift and go to state 23

state 70

    (57) logical_operator -> AND .

    INTEGER         reduce using rule 57 (logical_operator -> AND .)
    FLOAT           reduce using rule 57 (logical_operator -> AND .)
    STRING          reduce using rule 57 (logical_operator -> AND .)
    VARIABLE        reduce using rule 57 (logical_operator -> AND .)
    LPAREN          reduce using rule 57 (logical_operator -> AND .)


state 71

    (58) logical_operator -> OR .

    INTEGER         reduce using rule 58 (logical_operator -> OR .)
    FLOAT           reduce using rule 58 (logical_operator -> OR .)
    STRING          reduce using rule 58 (logical_operator -> OR .)
    VARIABLE        reduce using rule 58 (logical_operator -> OR .)
    LPAREN          reduce using rule 58 (logical_operator -> OR .)


state 72

    (59) logical_operator -> NOT .

    INTEGER         reduce using rule 59 (logical_operator -> NOT .)
    FLOAT           reduce using rule 59 (logical_operator -> NOT .)
    STRING          reduce using rule 59 (logical_operator -> NOT .)
    VARIABLE        reduce using rule 59 (logical_operator -> NOT .)
    LPAREN          reduce using rule 59 (logical_operator -> NOT .)


state 73

    (34) condition -> expression comparison_operator . expression
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    expression                     shift and go to state 96
    term                           shift and go to state 23

state 74

    (51) comparison_operator -> EQ .

    INTEGER         reduce using rule 51 (comparison_operator -> EQ .)
    FLOAT           reduce using rule 51 (comparison_operator -> EQ .)
    STRING          reduce using rule 51 (comparison_operator -> EQ .)
    VARIABLE        reduce using rule 51 (comparison_operator -> EQ .)
    LPAREN          reduce using rule 51 (comparison_operator -> EQ .)


state 75

    (52) comparison_operator -> NE .

    INTEGER         reduce using rule 52 (comparison_operator -> NE .)
    FLOAT           reduce using rule 52 (comparison_operator -> NE .)
    STRING          reduce using rule 52 (comparison_operator -> NE .)
    VARIABLE        reduce using rule 52 (comparison_operator -> NE .)
    LPAREN          reduce using rule 52 (comparison_operator -> NE .)


state 76

    (53) comparison_operator -> LT .

    INTEGER         reduce using rule 53 (comparison_operator -> LT .)
    FLOAT           reduce using rule 53 (comparison_operator -> LT .)
    STRING          reduce using rule 53 (comparison_operator -> LT .)
    VARIABLE        reduce using rule 53 (comparison_operator -> LT .)
    LPAREN          reduce using rule 53 (comparison_operator -> LT .)


state 77

    (54) comparison_operator -> LE .

    INTEGER         reduce using rule 54 (comparison_operator -> LE .)
    FLOAT           reduce using rule 54 (comparison_operator -> LE .)
    STRING          reduce using rule 54 (comparison_operator -> LE .)
    VARIABLE        reduce using rule 54 (comparison_operator -> LE .)
    LPAREN          reduce using rule 54 (comparison_operator -> LE .)


state 78

    (55) comparison_operator -> GT .

    INTEGER         reduce using rule 55 (comparison_operator -> GT .)
    FLOAT           reduce using rule 55 (comparison_operator -> GT .)
    STRING          reduce using rule 55 (comparison_operator -> GT .)
    VARIABLE        reduce using rule 55 (comparison_operator -> GT .)
    LPAREN          reduce using rule 55 (comparison_operator -> GT .)


state 79

    (56) comparison_operator -> GE .

    INTEGER         reduce using rule 56 (comparison_operator -> GE .)
    FLOAT           reduce using rule 56 (comparison_operator -> GE .)
    STRING          reduce using rule 56 (comparison_operator -> GE .)
    VARIABLE        reduce using rule 56 (comparison_operator -> GE .)
    LPAREN          reduce using rule 56 (comparison_operator -> GE .)


state 80

    (30) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list . RPAREN LBRACE statement_list RBRACE
    (32) parameter_list -> parameter_list . COMMA VARIABLE

    RPAREN          shift and go to state 97
    COMMA           shift and go to state 98


state 81

    (31) parameter_list -> VARIABLE .

    RPAREN          reduce using rule 31 (parameter_list -> VARIABLE .)
    COMMA           reduce using rule 31 (parameter_list -> VARIABLE .)


state 82

    (33) parameter_list -> empty .

    RPAREN          reduce using rule 33 (parameter_list -> empty .)
    COMMA           reduce using rule 33 (parameter_list -> empty .)


state 83

    (25) class_statement -> CLASS IDENTIFIER LBRACE class_body . RBRACE
    (27) class_body -> class_body . class_body_element
    (28) class_body_element -> . assignment_statement
    (29) class_body_element -> . function_statement
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE

    RBRACE          shift and go to state 99
    VARIABLE        shift and go to state 87
    FUNCTION        shift and go to state 20

    class_body_element             shift and go to state 100
    assignment_statement           shift and go to state 85
    function_statement             shift and go to state 86

state 84

    (26) class_body -> class_body_element .

    RBRACE          reduce using rule 26 (class_body -> class_body_element .)
    VARIABLE        reduce using rule 26 (class_body -> class_body_element .)
    FUNCTION        reduce using rule 26 (class_body -> class_body_element .)


state 85

    (28) class_body_element -> assignment_statement .

    RBRACE          reduce using rule 28 (class_body_element -> assignment_statement .)
    VARIABLE        reduce using rule 28 (class_body_element -> assignment_statement .)
    FUNCTION        reduce using rule 28 (class_body_element -> assignment_statement .)


state 86

    (29) class_body_element -> function_statement .

    RBRACE          reduce using rule 29 (class_body_element -> function_statement .)
    VARIABLE        reduce using rule 29 (class_body_element -> function_statement .)
    FUNCTION        reduce using rule 29 (class_body_element -> function_statement .)


state 87

    (19) assignment_statement -> VARIABLE . EQ expression SEMI

    EQ              shift and go to state 101


state 88

    (36) array -> ARRAY LPAREN arrayArg RPAREN . SEMI

    SEMI            shift and go to state 102


state 89

    (37) arrayArg -> index ARROW . value
    (38) arrayArg -> index ARROW . value arrayArg
    (39) arrayArg -> index ARROW . value COMMA arrayArg
    (45) value -> . VARIABLE
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . expression_statement
    (18) expression_statement -> . expression SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    VARIABLE        shift and go to state 104
    INTEGER         shift and go to state 105
    FLOAT           shift and go to state 106
    STRING          shift and go to state 26
    LPAREN          shift and go to state 15

    value                          shift and go to state 103
    expression_statement           shift and go to state 107
    expression                     shift and go to state 16
    term                           shift and go to state 23

state 90

    (14) print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .

    IDENTIFIER      reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    VARIABLE        reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    IF              reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    FUNCTION        reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    CLASS           reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    ARRAY           reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    INTEGER         reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    FLOAT           reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    STRING          reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    LPAREN          reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    $end            reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    ELSE            reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)
    RBRACE          reduce using rule 14 (print_statement -> IDENTIFIER LPAREN argument_list RPAREN SEMI .)


state 91

    (17) argument_list -> argument_list COMMA expression .
    (61) expression -> expression . PLUS term
    (62) expression -> expression . MINUS term
    (63) expression -> expression . TIMES term
    (64) expression -> expression . DIVIDE term
    (65) expression -> expression . MOD term
    (66) expression -> expression . EXP term

    RPAREN          reduce using rule 17 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 17 (argument_list -> argument_list COMMA expression .)
    RBRACKET        reduce using rule 17 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36
    EXP             shift and go to state 37


state 92

    (24) array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET . SEMI

    SEMI            shift and go to state 108


state 93

    (20) condition_statement -> IF LPAREN condition RPAREN statement .
    (21) condition_statement -> IF LPAREN condition RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    IDENTIFIER      reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    VARIABLE        reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    IF              reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    FUNCTION        reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    CLASS           reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    ARRAY           reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    INTEGER         reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    FLOAT           reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    STRING          reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    LPAREN          reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    $end            reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    RBRACE          reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .)
    ELSE            shift and go to state 109

  ! ELSE            [ reduce using rule 20 (condition_statement -> IF LPAREN condition RPAREN statement .) ]


state 94

    (42) ifStatement -> IF LPAREN condition RPAREN LBRACE . statement RBRACE SEMI
    (43) ifStatement -> IF LPAREN condition RPAREN LBRACE . statement RBRACE elseStatement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) statement -> . ifStatement
    (13) statement -> . array
    (14) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (15) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (18) expression_statement -> . expression SEMI
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (20) condition_statement -> . IF LPAREN condition RPAREN statement
    (21) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (22) data_structure_statement -> . array_statement
    (23) data_structure_statement -> . class_statement
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (25) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (42) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement
    (36) array -> . ARRAY LPAREN arrayArg RPAREN SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (24) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 14
    VARIABLE        shift and go to state 17
    IF              shift and go to state 18
    FUNCTION        shift and go to state 20
    CLASS           shift and go to state 21
    ARRAY           shift and go to state 22
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    LPAREN          shift and go to state 15

    statement                      shift and go to state 110
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    ifStatement                    shift and go to state 12
    array                          shift and go to state 13
    expression                     shift and go to state 16
    array_statement                shift and go to state 19
    term                           shift and go to state 23

state 95

    (35) condition -> condition logical_operator condition .
    (35) condition -> condition . logical_operator condition
    (57) logical_operator -> . AND
    (58) logical_operator -> . OR
    (59) logical_operator -> . NOT

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPAREN          reduce using rule 35 (condition -> condition logical_operator condition .)
    AND             shift and go to state 70
    OR              shift and go to state 71
    NOT             shift and go to state 72

  ! AND             [ reduce using rule 35 (condition -> condition logical_operator condition .) ]
  ! OR              [ reduce using rule 35 (condition -> condition logical_operator condition .) ]
  ! NOT             [ reduce using rule 35 (condition -> condition logical_operator condition .) ]

    logical_operator               shift and go to state 69

state 96

    (34) condition -> expression comparison_operator expression .
    (61) expression -> expression . PLUS term
    (62) expression -> expression . MINUS term
    (63) expression -> expression . TIMES term
    (64) expression -> expression . DIVIDE term
    (65) expression -> expression . MOD term
    (66) expression -> expression . EXP term

    RPAREN          reduce using rule 34 (condition -> expression comparison_operator expression .)
    AND             reduce using rule 34 (condition -> expression comparison_operator expression .)
    OR              reduce using rule 34 (condition -> expression comparison_operator expression .)
    NOT             reduce using rule 34 (condition -> expression comparison_operator expression .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36
    EXP             shift and go to state 37


state 97

    (30) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 111


state 98

    (32) parameter_list -> parameter_list COMMA . VARIABLE

    VARIABLE        shift and go to state 112


state 99

    (25) class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .

    IDENTIFIER      reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    VARIABLE        reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    IF              reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    FUNCTION        reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    CLASS           reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    ARRAY           reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    INTEGER         reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    FLOAT           reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    STRING          reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    LPAREN          reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    $end            reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    ELSE            reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 25 (class_statement -> CLASS IDENTIFIER LBRACE class_body RBRACE .)


state 100

    (27) class_body -> class_body class_body_element .

    RBRACE          reduce using rule 27 (class_body -> class_body class_body_element .)
    VARIABLE        reduce using rule 27 (class_body -> class_body class_body_element .)
    FUNCTION        reduce using rule 27 (class_body -> class_body class_body_element .)


state 101

    (19) assignment_statement -> VARIABLE EQ . expression SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    VARIABLE        shift and go to state 30
    LPAREN          shift and go to state 15

    expression                     shift and go to state 53
    term                           shift and go to state 23

state 102

    (36) array -> ARRAY LPAREN arrayArg RPAREN SEMI .

    IDENTIFIER      reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    VARIABLE        reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    IF              reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    FUNCTION        reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    CLASS           reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    ARRAY           reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    INTEGER         reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    FLOAT           reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    STRING          reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    LPAREN          reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    $end            reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    ELSE            reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)
    RBRACE          reduce using rule 36 (array -> ARRAY LPAREN arrayArg RPAREN SEMI .)


state 103

    (37) arrayArg -> index ARROW value .
    (38) arrayArg -> index ARROW value . arrayArg
    (39) arrayArg -> index ARROW value . COMMA arrayArg
    (37) arrayArg -> . index ARROW value
    (38) arrayArg -> . index ARROW value arrayArg
    (39) arrayArg -> . index ARROW value COMMA arrayArg
    (40) index -> . INTEGER
    (41) index -> . STRING

    RPAREN          reduce using rule 37 (arrayArg -> index ARROW value .)
    COMMA           shift and go to state 114
    INTEGER         shift and go to state 61
    STRING          shift and go to state 62

    index                          shift and go to state 60
    arrayArg                       shift and go to state 113

state 104

    (45) value -> VARIABLE .
    (70) term -> VARIABLE .

    COMMA           reduce using rule 45 (value -> VARIABLE .)
    INTEGER         reduce using rule 45 (value -> VARIABLE .)
    STRING          reduce using rule 45 (value -> VARIABLE .)
    RPAREN          reduce using rule 45 (value -> VARIABLE .)
    SEMI            reduce using rule 70 (term -> VARIABLE .)
    PLUS            reduce using rule 70 (term -> VARIABLE .)
    MINUS           reduce using rule 70 (term -> VARIABLE .)
    TIMES           reduce using rule 70 (term -> VARIABLE .)
    DIVIDE          reduce using rule 70 (term -> VARIABLE .)
    MOD             reduce using rule 70 (term -> VARIABLE .)
    EXP             reduce using rule 70 (term -> VARIABLE .)


state 105

    (46) value -> INTEGER .
    (67) term -> INTEGER .

    COMMA           reduce using rule 46 (value -> INTEGER .)
    INTEGER         reduce using rule 46 (value -> INTEGER .)
    STRING          reduce using rule 46 (value -> INTEGER .)
    RPAREN          reduce using rule 46 (value -> INTEGER .)
    SEMI            reduce using rule 67 (term -> INTEGER .)
    PLUS            reduce using rule 67 (term -> INTEGER .)
    MINUS           reduce using rule 67 (term -> INTEGER .)
    TIMES           reduce using rule 67 (term -> INTEGER .)
    DIVIDE          reduce using rule 67 (term -> INTEGER .)
    MOD             reduce using rule 67 (term -> INTEGER .)
    EXP             reduce using rule 67 (term -> INTEGER .)


state 106

    (47) value -> FLOAT .
    (68) term -> FLOAT .

    COMMA           reduce using rule 47 (value -> FLOAT .)
    INTEGER         reduce using rule 47 (value -> FLOAT .)
    STRING          reduce using rule 47 (value -> FLOAT .)
    RPAREN          reduce using rule 47 (value -> FLOAT .)
    SEMI            reduce using rule 68 (term -> FLOAT .)
    PLUS            reduce using rule 68 (term -> FLOAT .)
    MINUS           reduce using rule 68 (term -> FLOAT .)
    TIMES           reduce using rule 68 (term -> FLOAT .)
    DIVIDE          reduce using rule 68 (term -> FLOAT .)
    MOD             reduce using rule 68 (term -> FLOAT .)
    EXP             reduce using rule 68 (term -> FLOAT .)


state 107

    (48) value -> expression_statement .

    COMMA           reduce using rule 48 (value -> expression_statement .)
    INTEGER         reduce using rule 48 (value -> expression_statement .)
    STRING          reduce using rule 48 (value -> expression_statement .)
    RPAREN          reduce using rule 48 (value -> expression_statement .)


state 108

    (24) array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .

    IDENTIFIER      reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    VARIABLE        reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    IF              reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    FUNCTION        reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    CLASS           reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    ARRAY           reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    INTEGER         reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    FLOAT           reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    STRING          reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    LPAREN          reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    $end            reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    ELSE            reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)
    RBRACE          reduce using rule 24 (array_statement -> VARIABLE EQ LBRACKET argument_list RBRACKET SEMI .)


state 109

    (21) condition_statement -> IF LPAREN condition RPAREN statement ELSE . statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) statement -> . ifStatement
    (13) statement -> . array
    (14) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (15) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (18) expression_statement -> . expression SEMI
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (20) condition_statement -> . IF LPAREN condition RPAREN statement
    (21) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (22) data_structure_statement -> . array_statement
    (23) data_structure_statement -> . class_statement
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (25) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (42) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement
    (36) array -> . ARRAY LPAREN arrayArg RPAREN SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (24) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 14
    VARIABLE        shift and go to state 17
    IF              shift and go to state 18
    FUNCTION        shift and go to state 20
    CLASS           shift and go to state 21
    ARRAY           shift and go to state 22
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    LPAREN          shift and go to state 15

    statement                      shift and go to state 115
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    ifStatement                    shift and go to state 12
    array                          shift and go to state 13
    expression                     shift and go to state 16
    array_statement                shift and go to state 19
    term                           shift and go to state 23

state 110

    (42) ifStatement -> IF LPAREN condition RPAREN LBRACE statement . RBRACE SEMI
    (43) ifStatement -> IF LPAREN condition RPAREN LBRACE statement . RBRACE elseStatement

    RBRACE          shift and go to state 116


state 111

    (30) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE . statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) statement -> . ifStatement
    (13) statement -> . array
    (14) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (15) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (18) expression_statement -> . expression SEMI
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (20) condition_statement -> . IF LPAREN condition RPAREN statement
    (21) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (22) data_structure_statement -> . array_statement
    (23) data_structure_statement -> . class_statement
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (25) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (42) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement
    (36) array -> . ARRAY LPAREN arrayArg RPAREN SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (24) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 14
    VARIABLE        shift and go to state 17
    IF              shift and go to state 18
    FUNCTION        shift and go to state 20
    CLASS           shift and go to state 21
    ARRAY           shift and go to state 22
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    LPAREN          shift and go to state 15

    statement_list                 shift and go to state 117
    statement                      shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    ifStatement                    shift and go to state 12
    array                          shift and go to state 13
    expression                     shift and go to state 16
    array_statement                shift and go to state 19
    term                           shift and go to state 23

state 112

    (32) parameter_list -> parameter_list COMMA VARIABLE .

    RPAREN          reduce using rule 32 (parameter_list -> parameter_list COMMA VARIABLE .)
    COMMA           reduce using rule 32 (parameter_list -> parameter_list COMMA VARIABLE .)


state 113

    (38) arrayArg -> index ARROW value arrayArg .

    RPAREN          reduce using rule 38 (arrayArg -> index ARROW value arrayArg .)


state 114

    (39) arrayArg -> index ARROW value COMMA . arrayArg
    (37) arrayArg -> . index ARROW value
    (38) arrayArg -> . index ARROW value arrayArg
    (39) arrayArg -> . index ARROW value COMMA arrayArg
    (40) index -> . INTEGER
    (41) index -> . STRING

    INTEGER         shift and go to state 61
    STRING          shift and go to state 62

    index                          shift and go to state 60
    arrayArg                       shift and go to state 118

state 115

    (21) condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .

    IDENTIFIER      reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    VARIABLE        reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    IF              reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    FUNCTION        reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    CLASS           reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    ARRAY           reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    INTEGER         reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    STRING          reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    $end            reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    ELSE            reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 21 (condition_statement -> IF LPAREN condition RPAREN statement ELSE statement .)


state 116

    (42) ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE . SEMI
    (43) ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE . elseStatement
    (44) elseStatement -> . ELSE LBRACE statement RBRACE SEMI

    SEMI            shift and go to state 119
    ELSE            shift and go to state 121

    elseStatement                  shift and go to state 120

state 117

    (30) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list . RBRACE
    (3) statement_list -> statement_list . statement
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) statement -> . ifStatement
    (13) statement -> . array
    (14) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (15) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (18) expression_statement -> . expression SEMI
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (20) condition_statement -> . IF LPAREN condition RPAREN statement
    (21) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (22) data_structure_statement -> . array_statement
    (23) data_structure_statement -> . class_statement
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (25) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (42) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement
    (36) array -> . ARRAY LPAREN arrayArg RPAREN SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (24) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    RBRACE          shift and go to state 122
    IDENTIFIER      shift and go to state 14
    VARIABLE        shift and go to state 17
    IF              shift and go to state 18
    FUNCTION        shift and go to state 20
    CLASS           shift and go to state 21
    ARRAY           shift and go to state 22
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    LPAREN          shift and go to state 15

    statement                      shift and go to state 27
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    ifStatement                    shift and go to state 12
    array                          shift and go to state 13
    expression                     shift and go to state 16
    array_statement                shift and go to state 19
    term                           shift and go to state 23

state 118

    (39) arrayArg -> index ARROW value COMMA arrayArg .

    RPAREN          reduce using rule 39 (arrayArg -> index ARROW value COMMA arrayArg .)


state 119

    (42) ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .

    IDENTIFIER      reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    VARIABLE        reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    IF              reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    FUNCTION        reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    CLASS           reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    ARRAY           reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    INTEGER         reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    FLOAT           reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    STRING          reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    LPAREN          reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    $end            reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    ELSE            reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)
    RBRACE          reduce using rule 42 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI .)


state 120

    (43) ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .

    IDENTIFIER      reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    VARIABLE        reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    IF              reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    FUNCTION        reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    CLASS           reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    ARRAY           reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    INTEGER         reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    FLOAT           reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    STRING          reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    LPAREN          reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    $end            reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    ELSE            reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)
    RBRACE          reduce using rule 43 (ifStatement -> IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement .)


state 121

    (44) elseStatement -> ELSE . LBRACE statement RBRACE SEMI

    LBRACE          shift and go to state 123


state 122

    (30) function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .

    IDENTIFIER      reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    VARIABLE        reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    IF              reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    FUNCTION        reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    ARRAY           reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    INTEGER         reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    STRING          reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    $end            reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 30 (function_statement -> FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE .)


state 123

    (44) elseStatement -> ELSE LBRACE . statement RBRACE SEMI
    (4) statement -> . print_statement
    (5) statement -> . input_statement
    (6) statement -> . expression_statement
    (7) statement -> . assignment_statement
    (8) statement -> . condition_statement
    (9) statement -> . data_structure_statement
    (10) statement -> . function_statement
    (11) statement -> . class_statement
    (12) statement -> . ifStatement
    (13) statement -> . array
    (14) print_statement -> . IDENTIFIER LPAREN argument_list RPAREN SEMI
    (15) input_statement -> . IDENTIFIER LPAREN RPAREN SEMI
    (18) expression_statement -> . expression SEMI
    (19) assignment_statement -> . VARIABLE EQ expression SEMI
    (20) condition_statement -> . IF LPAREN condition RPAREN statement
    (21) condition_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (22) data_structure_statement -> . array_statement
    (23) data_structure_statement -> . class_statement
    (30) function_statement -> . FUNCTION IDENTIFIER LPAREN parameter_list RPAREN LBRACE statement_list RBRACE
    (25) class_statement -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (42) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE SEMI
    (43) ifStatement -> . IF LPAREN condition RPAREN LBRACE statement RBRACE elseStatement
    (36) array -> . ARRAY LPAREN arrayArg RPAREN SEMI
    (60) expression -> . term
    (61) expression -> . expression PLUS term
    (62) expression -> . expression MINUS term
    (63) expression -> . expression TIMES term
    (64) expression -> . expression DIVIDE term
    (65) expression -> . expression MOD term
    (66) expression -> . expression EXP term
    (24) array_statement -> . VARIABLE EQ LBRACKET argument_list RBRACKET SEMI
    (67) term -> . INTEGER
    (68) term -> . FLOAT
    (69) term -> . STRING
    (70) term -> . VARIABLE
    (71) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 14
    VARIABLE        shift and go to state 17
    IF              shift and go to state 18
    FUNCTION        shift and go to state 20
    CLASS           shift and go to state 21
    ARRAY           shift and go to state 22
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26
    LPAREN          shift and go to state 15

    statement                      shift and go to state 124
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    expression_statement           shift and go to state 6
    assignment_statement           shift and go to state 7
    condition_statement            shift and go to state 8
    data_structure_statement       shift and go to state 9
    function_statement             shift and go to state 10
    class_statement                shift and go to state 11
    ifStatement                    shift and go to state 12
    array                          shift and go to state 13
    expression                     shift and go to state 16
    array_statement                shift and go to state 19
    term                           shift and go to state 23

state 124

    (44) elseStatement -> ELSE LBRACE statement . RBRACE SEMI

    RBRACE          shift and go to state 125


state 125

    (44) elseStatement -> ELSE LBRACE statement RBRACE . SEMI

    SEMI            shift and go to state 126


state 126

    (44) elseStatement -> ELSE LBRACE statement RBRACE SEMI .

    IDENTIFIER      reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    VARIABLE        reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    IF              reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    FUNCTION        reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    CLASS           reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    ARRAY           reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    INTEGER         reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    FLOAT           reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    STRING          reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    LPAREN          reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    $end            reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    ELSE            reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)
    RBRACE          reduce using rule 44 (elseStatement -> ELSE LBRACE statement RBRACE SEMI .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 93 resolved as shift
WARNING: shift/reduce conflict for AND in state 95 resolved as shift
WARNING: shift/reduce conflict for OR in state 95 resolved as shift
WARNING: shift/reduce conflict for NOT in state 95 resolved as shift
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> class_statement)
WARNING: rejected rule (data_structure_statement -> class_statement) in state 11
WARNING: Rule (data_structure_statement -> class_statement) is never reduced
